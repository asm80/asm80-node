0000                          ;**************************************************************
0000                          ;*
0000                          ;*             C P / M   version   2 . 2
0000                          ;*
0000                          ;*   Reconstructed from memory image on February 27, 1981
0000                          ;*
0000                          ;*                by Clark A. Calkins
0000                          ;*
0000                          ;**************************************************************
0000                          ; 
0000                          ;   Set memory limit here. This is the amount of contigeous
0000                          ; ram starting from 0000. CP/M will reside at the end of this space.
0000                          ; 
0000                MEM:      EQU   62   
0000                          ; 
0000                IOBYTE:   EQU   3   
0000                TDRIVE:   EQU   4   
0000                ENTRY:    EQU   5   
0000                TFCB:     EQU   5CH   
0000                TBUFF:    EQU   80H   
0000                TBASE:    EQU   100H   
0000                          ; 
0000                          ;   Set control character equates.
0000                          ; 
0000                CNTRLC:   EQU   3   
0000                CNTRLE:   EQU   05H   
0000                BS:       EQU   08H   
0000                TAB:      EQU   09H   
0000                LF:       EQU   0AH   
0000                FF:       EQU   0CH   
0000                CR:       EQU   0DH   
0000                CNTRLP:   EQU   10H   
0000                CNTRLR:   EQU   12H   
0000                CNTRLS:   EQU   13H   
0000                CNTRLU:   EQU   15H   
0000                CNTRLX:   EQU   18H   
0000                CNTRLZ:   EQU   1AH   
0000                DEL:      EQU   7FH   
0000                          ; 
0000                          ;   Set origin for CP/M
0000                          ; 
DC00                          .ORG   (MEM-7)*1024   
DC00                          ; 
DC00   C3 5C DF     CBASE:    JP   COMMAND   ;execute command processor (ccp).
DC03   C3 58 DF               JP   CLEARBUF   ;entry to empty input buffer before starting ccp.
DC06                          ; 
DC06                          ;   Standard cp/m ccp input buffer. Format is (max length),
DC06                          ; (actual length), (char #1), (char #2), (char #3), etc.
DC06                          ; 
DC06   7F           INBUFF:   DB   127   ;length of input buffer.
DC07   00                     DB   0   ;current length of contents.
DC08   43 6F 70 79 72 69 67 68 74 DB   'Copyright'   
DC11   20 31 39 37 39 20 28 63 29 20 62 79 20 44 69 67 69 74 61 6C 20 52 65 73 65 61 72 63 68 20 20 20 20 20 20 DB   ' 1979 (c) by Digital Research      '   
DC34   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
DC4B   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
DC62   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
DC79   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
DC88   08 DC        INPOINT:   DW   INBUFF+2   ;input line pointer
DC8A   00 00        NAMEPNT:   DW   0   ;input line pointer used for error message. Points to
DC8C                          ;			;start of name in error.
DC8C                          ; 
DC8C                          ;   Routine to print (A) on the console. All registers used.
DC8C                          ; 
DC8C   5F           PRINT:    LD   E,A   ;setup bdos call.
DC8D   0E 02                  LD   C,2   
DC8F   C3 05 00               JP   ENTRY   
DC92                          ; 
DC92                          ;   Routine to print (A) on the console and to save (BC).
DC92                          ; 
DC92   C5           PRINTB:   PUSH   BC   
DC93   CD 8C DC               CALL   PRINT   
DC96   C1                     POP   BC   
DC97   C9                     RET   
DC98                          ; 
DC98                          ;   Routine to send a carriage return, line feed combination
DC98                          ; to the console.
DC98                          ; 
DC98   3E 0D        CRLF:     LD   A,CR   
DC9A   CD 92 DC               CALL   PRINTB   
DC9D   3E 0A                  LD   A,LF   
DC9F   C3 92 DC               JP   PRINTB   
DCA2                          ; 
DCA2                          ;   Routine to send one space to the console and save (BC).
DCA2                          ; 
DCA2   3E 20        SPACE:    LD   A,' '   
DCA4   C3 92 DC               JP   PRINTB   
DCA7                          ; 
DCA7                          ;   Routine to print character string pointed to be (BC) on the
DCA7                          ; console. It must terminate with a null byte.
DCA7                          ; 
DCA7   C5           PLINE:    PUSH   BC   
DCA8   CD 98 DC               CALL   CRLF   
DCAB   E1                     POP   HL   
DCAC   7E           PLINE2:   LD   A,(HL)   
DCAD   B7                     OR   A   
DCAE   C8                     RET   Z   
DCAF   23                     INC   HL   
DCB0   E5                     PUSH   HL   
DCB1   CD 8C DC               CALL   PRINT   
DCB4   E1                     POP   HL   
DCB5   C3 AC DC               JP   PLINE2   
DCB8                          ; 
DCB8                          ;   Routine to reset the disk system.
DCB8                          ; 
DCB8   0E 0D        RESDSK:   LD   C,13   
DCBA   C3 05 00               JP   ENTRY   
DCBD                          ; 
DCBD                          ;   Routine to select disk (A).
DCBD                          ; 
DCBD   5F           DSKSEL:   LD   E,A   
DCBE   0E 0E                  LD   C,14   
DCC0   C3 05 00               JP   ENTRY   
DCC3                          ; 
DCC3                          ;   Routine to call bdos and save the return code. The zero
DCC3                          ; flag is set on a return of 0ffh.
DCC3                          ; 
DCC3   CD 05 00     ENTRY1:   CALL   ENTRY   
DCC6   32 EE E3               LD   (RTNCODE),A   ;save return code.
DCC9   3C                     INC   A   ;set zero if 0ffh returned.
DCCA   C9                     RET   
DCCB                          ; 
DCCB                          ;   Routine to open a file. (DE) must point to the FCB.
DCCB                          ; 
DCCB   0E 0F        OPEN:     LD   C,15   
DCCD   C3 C3 DC               JP   ENTRY1   
DCD0                          ; 
DCD0                          ;   Routine to open file at (FCB).
DCD0                          ; 
DCD0   AF           OPENFCB:   XOR   A   ;clear the record number byte at fcb+32
DCD1   32 ED E3               LD   (FCB+32),A   
DCD4   11 CD E3               LD   DE,FCB   
DCD7   C3 CB DC               JP   OPEN   
DCDA                          ; 
DCDA                          ;   Routine to close a file. (DE) points to FCB.
DCDA                          ; 
DCDA   0E 10        CLOSE:    LD   C,16   
DCDC   C3 C3 DC               JP   ENTRY1   
DCDF                          ; 
DCDF                          ;   Routine to search for the first file with ambigueous name
DCDF                          ; (DE).
DCDF                          ; 
DCDF   0E 11        SRCHFST:   LD   C,17   
DCE1   C3 C3 DC               JP   ENTRY1   
DCE4                          ; 
DCE4                          ;   Search for the next ambigeous file name.
DCE4                          ; 
DCE4   0E 12        SRCHNXT:   LD   C,18   
DCE6   C3 C3 DC               JP   ENTRY1   
DCE9                          ; 
DCE9                          ;   Search for file at (FCB).
DCE9                          ; 
DCE9   11 CD E3     SRCHFCB:   LD   DE,FCB   
DCEC   C3 DF DC               JP   SRCHFST   
DCEF                          ; 
DCEF                          ;   Routine to delete a file pointed to by (DE).
DCEF                          ; 
DCEF   0E 13        DELETE:   LD   C,19   
DCF1   C3 05 00               JP   ENTRY   
DCF4                          ; 
DCF4                          ;   Routine to call the bdos and set the zero flag if a zero
DCF4                          ; status is returned.
DCF4                          ; 
DCF4   CD 05 00     ENTRY2:   CALL   ENTRY   
DCF7   B7                     OR   A   ;set zero flag if appropriate.
DCF8   C9                     RET   
DCF9                          ; 
DCF9                          ;   Routine to read the next record from a sequential file.
DCF9                          ; (DE) points to the FCB.
DCF9                          ; 
DCF9   0E 14        RDREC:    LD   C,20   
DCFB   C3 F4 DC               JP   ENTRY2   
DCFE                          ; 
DCFE                          ;   Routine to read file at (FCB).
DCFE                          ; 
DCFE   11 CD E3     READFCB:   LD   DE,FCB   
DD01   C3 F9 DC               JP   RDREC   
DD04                          ; 
DD04                          ;   Routine to write the next record of a sequential file.
DD04                          ; (DE) points to the FCB.
DD04                          ; 
DD04   0E 15        WRTREC:   LD   C,21   
DD06   C3 F4 DC               JP   ENTRY2   
DD09                          ; 
DD09                          ;   Routine to create the file pointed to by (DE).
DD09                          ; 
DD09   0E 16        CREATE:   LD   C,22   
DD0B   C3 C3 DC               JP   ENTRY1   
DD0E                          ; 
DD0E                          ;   Routine to rename the file pointed to by (DE). Note that
DD0E                          ; the new name starts at (DE+16).
DD0E                          ; 
DD0E   0E 17        RENAM:    LD   C,23   
DD10   C3 05 00               JP   ENTRY   
DD13                          ; 
DD13                          ;   Get the current user code.
DD13                          ; 
DD13   1E FF        GETUSR:   LD   E,0FFH   
DD15                          ; 
DD15                          ;   Routne to get or set the current user code.
DD15                          ; If (E) is FF then this is a GET, else it is a SET.
DD15                          ; 
DD15   0E 20        GETSETUC:   LD   C,32   
DD17   C3 05 00               JP   ENTRY   
DD1A                          ; 
DD1A                          ;   Routine to set the current drive byte at (TDRIVE).
DD1A                          ; 
DD1A   CD 13 DD     SETCDRV:   CALL   GETUSR   ;get user number
DD1D   87                     ADD   A,A   ;and shift into the upper 4 bits.
DD1E   87                     ADD   A,A   
DD1F   87                     ADD   A,A   
DD20   87                     ADD   A,A   
DD21   21 EF E3               LD   HL,CDRIVE   ;now add in the current drive number.
DD24   B6                     OR   (HL)   
DD25   32 04 00               LD   (TDRIVE),A   ;and save.
DD28   C9                     RET   
DD29                          ; 
DD29                          ;   Move currently active drive down to (TDRIVE).
DD29                          ; 
DD29   3A EF E3     MOVECD:   LD   A,(CDRIVE)   
DD2C   32 04 00               LD   (TDRIVE),A   
DD2F   C9                     RET   
DD30                          ; 
DD30                          ;   Routine to convert (A) into upper case ascii. Only letters
DD30                          ; are affected.
DD30                          ; 
DD30   FE 61        UPPER:    CP   'a'   ;check for letters in the range of 'a' to 'z'.
DD32   D8                     RET   C   
DD33   FE 7B                  CP   '{'   
DD35   D0                     RET   NC   
DD36   E6 5F                  AND   5FH   ;convert it if found.
DD38   C9                     RET   
DD39                          ; 
DD39                          ;   Routine to get a line of input. We must check to see if the
DD39                          ; user is in (BATCH) mode. If so, then read the input from file
DD39                          ; ($$$.SUB). At the end, reset to console input.
DD39                          ; 
DD39   3A AB E3     GETINP:   LD   A,(BATCH)   ;if =0, then use console input.
DD3C   B7                     OR   A   
DD3D   CA 96 DD               JP   Z,GETINP1   
DD40                          ; 
DD40                          ;   Use the submit file ($$$.sub) which is prepared by a
DD40                          ; SUBMIT run. It must be on drive (A) and it will be deleted
DD40                          ; if and error occures (like eof).
DD40                          ; 
DD40   3A EF E3               LD   A,(CDRIVE)   ;select drive 0 if need be.
DD43   B7                     OR   A   
DD44   3E 00                  LD   A,0   ;always use drive A for submit.
DD46   C4 BD DC               CALL   NZ,DSKSEL   ;select it if required.
DD49   11 AC E3               LD   DE,BATCHFCB   
DD4C   CD CB DC               CALL   OPEN   ;look for it.
DD4F   CA 96 DD               JP   Z,GETINP1   ;if not there, use normal input.
DD52   3A BB E3               LD   A,(BATCHFCB+15)   ;get last record number+1.
DD55   3D                     DEC   A   
DD56   32 CC E3               LD   (BATCHFCB+32),A   
DD59   11 AC E3               LD   DE,BATCHFCB   
DD5C   CD F9 DC               CALL   RDREC   ;read last record.
DD5F   C2 96 DD               JP   NZ,GETINP1   ;quit on end of file.
DD62                          ; 
DD62                          ;   Move this record into input buffer.
DD62                          ; 
DD62   11 07 DC               LD   DE,INBUFF+1   
DD65   21 80 00               LD   HL,TBUFF   ;data was read into buffer here.
DD68   06 80                  LD   B,128   ;all 128 characters may be used.
DD6A   CD 42 E0               CALL   HL2DE   ;(HL) to (DE), (B) bytes.
DD6D   21 BA E3               LD   HL,BATCHFCB+14   
DD70   36 00                  LD   (HL),0   ;zero out the 's2' byte.
DD72   23                     INC   HL   ;and decrement the record count.
DD73   35                     DEC   (HL)   
DD74   11 AC E3               LD   DE,BATCHFCB   ;close the batch file now.
DD77   CD DA DC               CALL   CLOSE   
DD7A   CA 96 DD               JP   Z,GETINP1   ;quit on an error.
DD7D   3A EF E3               LD   A,(CDRIVE)   ;re-select previous drive if need be.
DD80   B7                     OR   A   
DD81   C4 BD DC               CALL   NZ,DSKSEL   ;don't do needless selects.
DD84                          ; 
DD84                          ;   Print line just read on console.
DD84                          ; 
DD84   21 08 DC               LD   HL,INBUFF+2   
DD87   CD AC DC               CALL   PLINE2   
DD8A   CD C2 DD               CALL   CHKCON   ;check console, quit on a key.
DD8D   CA A7 DD               JP   Z,GETINP2   ;jump if no key is pressed.
DD90                          ; 
DD90                          ;   Terminate the submit job on any keyboard input. Delete this
DD90                          ; file such that it is not re-started and jump to normal keyboard
DD90                          ; input section.
DD90                          ; 
DD90   CD DD DD               CALL   DELBATCH   ;delete the batch file.
DD93   C3 82 DF               JP   CMMND1   ;and restart command input.
DD96                          ; 
DD96                          ;   Get here for normal keyboard input. Delete the submit file
DD96                          ; incase there was one.
DD96                          ; 
DD96   CD DD DD     GETINP1:   CALL   DELBATCH   ;delete file ($$$.sub).
DD99   CD 1A DD               CALL   SETCDRV   ;reset active disk.
DD9C   0E 0A                  LD   C,10   ;get line from console device.
DD9E   11 06 DC               LD   DE,INBUFF   
DDA1   CD 05 00               CALL   ENTRY   
DDA4   CD 29 DD               CALL   MOVECD   ;reset current drive (again).
DDA7                          ; 
DDA7                          ;   Convert input line to upper case.
DDA7                          ; 
DDA7   21 07 DC     GETINP2:   LD   HL,INBUFF+1   
DDAA   46                     LD   B,(HL)   ;(B)=character counter.
DDAB   23           GETINP3:   INC   HL   
DDAC   78                     LD   A,B   ;end of the line?
DDAD   B7                     OR   A   
DDAE   CA BA DD               JP   Z,GETINP4   
DDB1   7E                     LD   A,(HL)   ;convert to upper case.
DDB2   CD 30 DD               CALL   UPPER   
DDB5   77                     LD   (HL),A   
DDB6   05                     DEC   B   ;adjust character count.
DDB7   C3 AB DD               JP   GETINP3   
DDBA   77           GETINP4:   LD   (HL),A   ;add trailing null.
DDBB   21 08 DC               LD   HL,INBUFF+2   
DDBE   22 88 DC               LD   (INPOINT),HL   ;reset input line pointer.
DDC1   C9                     RET   
DDC2                          ; 
DDC2                          ;   Routine to check the console for a key pressed. The zero
DDC2                          ; flag is set is none, else the character is returned in (A).
DDC2                          ; 
DDC2   0E 0B        CHKCON:   LD   C,11   ;check console.
DDC4   CD 05 00               CALL   ENTRY   
DDC7   B7                     OR   A   
DDC8   C8                     RET   Z   ;return if nothing.
DDC9   0E 01                  LD   C,1   ;else get character.
DDCB   CD 05 00               CALL   ENTRY   
DDCE   B7                     OR   A   ;clear zero flag and return.
DDCF   C9                     RET   
DDD0                          ; 
DDD0                          ;   Routine to get the currently active drive number.
DDD0                          ; 
DDD0   0E 19        GETDSK:   LD   C,25   
DDD2   C3 05 00               JP   ENTRY   
DDD5                          ; 
DDD5                          ;   Set the stabdard dma address.
DDD5                          ; 
DDD5   11 80 00     STDDMA:   LD   DE,TBUFF   
DDD8                          ; 
DDD8                          ;   Routine to set the dma address to (DE).
DDD8                          ; 
DDD8   0E 1A        DMASET:   LD   C,26   
DDDA   C3 05 00               JP   ENTRY   
DDDD                          ; 
DDDD                          ;  Delete the batch file created by SUBMIT.
DDDD                          ; 
DDDD   21 AB E3     DELBATCH:   LD   HL,BATCH   ;is batch active?
DDE0   7E                     LD   A,(HL)   
DDE1   B7                     OR   A   
DDE2   C8                     RET   Z   
DDE3   36 00                  LD   (HL),0   ;yes, de-activate it.
DDE5   AF                     XOR   A   
DDE6   CD BD DC               CALL   DSKSEL   ;select drive 0 for sure.
DDE9   11 AC E3               LD   DE,BATCHFCB   ;and delete this file.
DDEC   CD EF DC               CALL   DELETE   
DDEF   3A EF E3               LD   A,(CDRIVE)   ;reset current drive.
DDF2   C3 BD DC               JP   DSKSEL   
DDF5                          ; 
DDF5                          ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
DDF5                          ; the same or we halt....
DDF5                          ; 
DDF5   11 28 DF     VERIFY:   LD   DE,PATTRN1   ;these are the serial number bytes.
DDF8   21 00 E4               LD   HL,PATTRN2   ;ditto, but how could they be different?
DDFB   06 06                  LD   B,6   ;6 bytes each.
DDFD   1A           VERIFY1:   LD   A,(DE)   
DDFE   BE                     CP   (HL)   
DDFF   C2 CF DF               JP   NZ,HALT   ;jump to halt routine.
DE02   13                     INC   DE   
DE03   23                     INC   HL   
DE04   05                     DEC   B   
DE05   C2 FD DD               JP   NZ,VERIFY1   
DE08   C9                     RET   
DE09                          ; 
DE09                          ;   Print back file name with a '?' to indicate a syntax error.
DE09                          ; 
DE09   CD 98 DC     SYNERR:   CALL   CRLF   ;end current line.
DE0C   2A 8A DC               LD   HL,(NAMEPNT)   ;this points to name in error.
DE0F   7E           SYNERR1:   LD   A,(HL)   ;print it until a space or null is found.
DE10   FE 20                  CP   ' '   
DE12   CA 22 DE               JP   Z,SYNERR2   
DE15   B7                     OR   A   
DE16   CA 22 DE               JP   Z,SYNERR2   
DE19   E5                     PUSH   HL   
DE1A   CD 8C DC               CALL   PRINT   
DE1D   E1                     POP   HL   
DE1E   23                     INC   HL   
DE1F   C3 0F DE               JP   SYNERR1   
DE22   3E 3F        SYNERR2:   LD   A,'?'   ;add trailing '?'.
DE24   CD 8C DC               CALL   PRINT   
DE27   CD 98 DC               CALL   CRLF   
DE2A   CD DD DD               CALL   DELBATCH   ;delete any batch file.
DE2D   C3 82 DF               JP   CMMND1   ;and restart from console input.
DE30                          ; 
DE30                          ;   Check character at (DE) for legal command input. Note that the
DE30                          ; zero flag is set if the character is a delimiter.
DE30                          ; 
DE30   1A           CHECK:    LD   A,(DE)   
DE31   B7                     OR   A   
DE32   C8                     RET   Z   
DE33   FE 20                  CP   ' '   ;control characters are not legal here.
DE35   DA 09 DE               JP   C,SYNERR   
DE38   C8                     RET   Z   ;check for valid delimiter.
DE39   FE 3D                  CP   '='   
DE3B   C8                     RET   Z   
DE3C   FE 5F                  CP   '_'   
DE3E   C8                     RET   Z   
DE3F   FE 2E                  CP   '.'   
DE41   C8                     RET   Z   
DE42   FE 3A                  CP   ':'   
DE44   C8                     RET   Z   
DE45   FE 3B                  CP   ";"   
DE47   C8                     RET   Z   
DE48   FE 3C                  CP   '<'   
DE4A   C8                     RET   Z   
DE4B   FE 3E                  CP   '>'   
DE4D   C8                     RET   Z   
DE4E   C9                     RET   
DE4F                          ; 
DE4F                          ;   Get the next non-blank character from (DE).
DE4F                          ; 
DE4F   1A           NONBLANK:   LD   A,(DE)   
DE50   B7                     OR   A   ;string ends with a null.
DE51   C8                     RET   Z   
DE52   FE 20                  CP   ' '   
DE54   C0                     RET   NZ   
DE55   13                     INC   DE   
DE56   C3 4F DE               JP   NONBLANK   
DE59                          ; 
DE59                          ;   Add (HL)=(HL)+(A)
DE59                          ; 
DE59   85           ADDHL:    ADD   A,L   
DE5A   6F                     LD   L,A   
DE5B   D0                     RET   NC   ;take care of any carry.
DE5C   24                     INC   H   
DE5D   C9                     RET   
DE5E                          ; 
DE5E                          ;   Convert the first name in (FCB).
DE5E                          ; 
DE5E   3E 00        CONVFST:   LD   A,0   
DE60                          ; 
DE60                          ;   Format a file name (convert * to '?', etc.). On return,
DE60                          ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
DE60                          ; the position within the fcb for the name (either 0 or 16).
DE60                          ; 
DE60   21 CD E3     CONVERT:   LD   HL,FCB   
DE63   CD 59 DE               CALL   ADDHL   
DE66   E5                     PUSH   HL   
DE67   E5                     PUSH   HL   
DE68   AF                     XOR   A   
DE69   32 F0 E3               LD   (CHGDRV),A   ;initialize drive change flag.
DE6C   2A 88 DC               LD   HL,(INPOINT)   ;set (HL) as pointer into input line.
DE6F   EB                     EX   DE,HL   
DE70   CD 4F DE               CALL   NONBLANK   ;get next non-blank character.
DE73   EB                     EX   DE,HL   
DE74   22 8A DC               LD   (NAMEPNT),HL   ;save pointer here for any error message.
DE77   EB                     EX   DE,HL   
DE78   E1                     POP   HL   
DE79   1A                     LD   A,(DE)   ;get first character.
DE7A   B7                     OR   A   
DE7B   CA 89 DE               JP   Z,CONVRT1   
DE7E   DE 40                  SBC   A,'A'-1   ;might be a drive name, convert to binary.
DE80   47                     LD   B,A   ;and save.
DE81   13                     INC   DE   ;check next character for a ':'.
DE82   1A                     LD   A,(DE)   
DE83   FE 3A                  CP   ':'   
DE85   CA 90 DE               JP   Z,CONVRT2   
DE88   1B                     DEC   DE   ;nope, move pointer back to the start of the line.
DE89   3A EF E3     CONVRT1:   LD   A,(CDRIVE)   
DE8C   77                     LD   (HL),A   
DE8D   C3 96 DE               JP   CONVRT3   
DE90   78           CONVRT2:   LD   A,B   
DE91   32 F0 E3               LD   (CHGDRV),A   ;set change in drives flag.
DE94   70                     LD   (HL),B   
DE95   13                     INC   DE   
DE96                          ; 
DE96                          ;   Convert the basic file name.
DE96                          ; 
DE96   06 08        CONVRT3:   LD   B,08H   
DE98   CD 30 DE     CONVRT4:   CALL   CHECK   
DE9B   CA B9 DE               JP   Z,CONVRT8   
DE9E   23                     INC   HL   
DE9F   FE 2A                  CP   '*'   ;note that an '*' will fill the remaining
DEA1   C2 A9 DE               JP   NZ,CONVRT5   ;field with '?'.
DEA4   36 3F                  LD   (HL),'?'   
DEA6   C3 AB DE               JP   CONVRT6   
DEA9   77           CONVRT5:   LD   (HL),A   
DEAA   13                     INC   DE   
DEAB   05           CONVRT6:   DEC   B   
DEAC   C2 98 DE               JP   NZ,CONVRT4   
DEAF   CD 30 DE     CONVRT7:   CALL   CHECK   ;get next delimiter.
DEB2   CA C0 DE               JP   Z,GETEXT   
DEB5   13                     INC   DE   
DEB6   C3 AF DE               JP   CONVRT7   
DEB9   23           CONVRT8:   INC   HL   ;blank fill the file name.
DEBA   36 20                  LD   (HL),' '   
DEBC   05                     DEC   B   
DEBD   C2 B9 DE               JP   NZ,CONVRT8   
DEC0                          ; 
DEC0                          ;   Get the extension and convert it.
DEC0                          ; 
DEC0   06 03        GETEXT:   LD   B,03H   
DEC2   FE 2E                  CP   '.'   
DEC4   C2 E9 DE               JP   NZ,GETEXT5   
DEC7   13                     INC   DE   
DEC8   CD 30 DE     GETEXT1:   CALL   CHECK   
DECB   CA E9 DE               JP   Z,GETEXT5   
DECE   23                     INC   HL   
DECF   FE 2A                  CP   '*'   
DED1   C2 D9 DE               JP   NZ,GETEXT2   
DED4   36 3F                  LD   (HL),'?'   
DED6   C3 DB DE               JP   GETEXT3   
DED9   77           GETEXT2:   LD   (HL),A   
DEDA   13                     INC   DE   
DEDB   05           GETEXT3:   DEC   B   
DEDC   C2 C8 DE               JP   NZ,GETEXT1   
DEDF   CD 30 DE     GETEXT4:   CALL   CHECK   
DEE2   CA F0 DE               JP   Z,GETEXT6   
DEE5   13                     INC   DE   
DEE6   C3 DF DE               JP   GETEXT4   
DEE9   23           GETEXT5:   INC   HL   
DEEA   36 20                  LD   (HL),' '   
DEEC   05                     DEC   B   
DEED   C2 E9 DE               JP   NZ,GETEXT5   
DEF0   06 03        GETEXT6:   LD   B,3   
DEF2   23           GETEXT7:   INC   HL   
DEF3   36 00                  LD   (HL),0   
DEF5   05                     DEC   B   
DEF6   C2 F2 DE               JP   NZ,GETEXT7   
DEF9   EB                     EX   DE,HL   
DEFA   22 88 DC               LD   (INPOINT),HL   ;save input line pointer.
DEFD   E1                     POP   HL   
DEFE                          ; 
DEFE                          ;   Check to see if this is an ambigeous file name specification.
DEFE                          ; Set the (A) register to non zero if it is.
DEFE                          ; 
DEFE   01 0B 00               LD   BC,11   ;set name length.
DF01   23           GETEXT8:   INC   HL   
DF02   7E                     LD   A,(HL)   
DF03   FE 3F                  CP   '?'   ;any question marks?
DF05   C2 09 DF               JP   NZ,GETEXT9   
DF08   04                     INC   B   ;count them.
DF09   0D           GETEXT9:   DEC   C   
DF0A   C2 01 DF               JP   NZ,GETEXT8   
DF0D   78                     LD   A,B   
DF0E   B7                     OR   A   
DF0F   C9                     RET   
DF10                          ; 
DF10                          ;   CP/M command table. Note commands can be either 3 or 4 characters long.
DF10                          ; 
DF10                NUMCMDS:   EQU   6   
DF10   44 49 52 20  CMDTBL:   DB   'DIR '   
DF14   45 52 41 20            DB   'ERA '   
DF18   54 59 50 45            DB   'TYPE'   
DF1C   53 41 56 45            DB   'SAVE'   
DF20   52 45 4E 20            DB   'REN '   
DF24   55 53 45 52            DB   'USER'   
DF28                          ; 
DF28                          ;   The following six bytes must agree with those at (PATTRN2)
DF28                          ; or cp/m will HALT. Why?
DF28                          ; 
DF28   00 16 00 00 00 00 PATTRN1:   DB   0,22,0,0,0,0   ;(* serial number bytes *).
DF2E                          ; 
DF2E                          ;   Search the command table for a match with what has just
DF2E                          ; been entered. If a match is found, then we jump to the
DF2E                          ; proper section. Else jump to (UNKNOWN).
DF2E                          ; On return, the (C) register is set to the command number
DF2E                          ; that matched (or NUMCMDS+1 if no match).
DF2E                          ; 
DF2E   21 10 DF     SEARCH:   LD   HL,CMDTBL   
DF31   0E 00                  LD   C,0   
DF33   79           SEARCH1:   LD   A,C   
DF34   FE 06                  CP   NUMCMDS   ;this commands exists.
DF36   D0                     RET   NC   
DF37   11 CE E3               LD   DE,FCB+1   ;check this one.
DF3A   06 04                  LD   B,4   ;max command length.
DF3C   1A           SEARCH2:   LD   A,(DE)   
DF3D   BE                     CP   (HL)   
DF3E   C2 4F DF               JP   NZ,SEARCH3   ;not a match.
DF41   13                     INC   DE   
DF42   23                     INC   HL   
DF43   05                     DEC   B   
DF44   C2 3C DF               JP   NZ,SEARCH2   
DF47   1A                     LD   A,(DE)   ;allow a 3 character command to match.
DF48   FE 20                  CP   ' '   
DF4A   C2 54 DF               JP   NZ,SEARCH4   
DF4D   79                     LD   A,C   ;set return register for this command.
DF4E   C9                     RET   
DF4F   23           SEARCH3:   INC   HL   
DF50   05                     DEC   B   
DF51   C2 4F DF               JP   NZ,SEARCH3   
DF54   0C           SEARCH4:   INC   C   
DF55   C3 33 DF               JP   SEARCH1   
DF58                          ; 
DF58                          ;   Set the input buffer to empty and then start the command
DF58                          ; processor (ccp).
DF58                          ; 
DF58   AF           CLEARBUF:   XOR   A   
DF59   32 07 DC               LD   (INBUFF+1),A   ;second byte is actual length.
DF5C                          ; 
DF5C                          ;**************************************************************
DF5C                          ;*
DF5C                          ;*
DF5C                          ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
DF5C                          ;*
DF5C                          ;**************************************************************
DF5C                          ;*
DF5C   31 AB E3     COMMAND:   LD   SP,CCPSTACK   ;setup stack area.
DF5F   C5                     PUSH   BC   ;note that (C) should be equal to:
DF60   79                     LD   A,C   ;(uuuudddd) where 'uuuu' is the user number
DF61   1F                     RRA   ;and 'dddd' is the drive number.
DF62   1F                     RRA   
DF63   1F                     RRA   
DF64   1F                     RRA   
DF65   E6 0F                  AND   0FH   ;isolate the user number.
DF67   5F                     LD   E,A   
DF68   CD 15 DD               CALL   GETSETUC   ;and set it.
DF6B   CD B8 DC               CALL   RESDSK   ;reset the disk system.
DF6E   32 AB E3               LD   (BATCH),A   ;clear batch mode flag.
DF71   C1                     POP   BC   
DF72   79                     LD   A,C   
DF73   E6 0F                  AND   0FH   ;isolate the drive number.
DF75   32 EF E3               LD   (CDRIVE),A   ;and save.
DF78   CD BD DC               CALL   DSKSEL   ;...and select.
DF7B   3A 07 DC               LD   A,(INBUFF+1)   
DF7E   B7                     OR   A   ;anything in input buffer already?
DF7F   C2 98 DF               JP   NZ,CMMND2   ;yes, we just process it.
DF82                          ; 
DF82                          ;   Entry point to get a command line from the console.
DF82                          ; 
DF82   31 AB E3     CMMND1:   LD   SP,CCPSTACK   ;set stack straight.
DF85   CD 98 DC               CALL   CRLF   ;start a new line on the screen.
DF88   CD D0 DD               CALL   GETDSK   ;get current drive.
DF8B   C6 61                  ADD   A,'a'   
DF8D   CD 8C DC               CALL   PRINT   ;print current drive.
DF90   3E 3E                  LD   A,'>'   
DF92   CD 8C DC               CALL   PRINT   ;and add prompt.
DF95   CD 39 DD               CALL   GETINP   ;get line from user.
DF98                          ; 
DF98                          ;   Process command line here.
DF98                          ; 
DF98   11 80 00     CMMND2:   LD   DE,TBUFF   
DF9B   CD D8 DD               CALL   DMASET   ;set standard dma address.
DF9E   CD D0 DD               CALL   GETDSK   
DFA1   32 EF E3               LD   (CDRIVE),A   ;set current drive.
DFA4   CD 5E DE               CALL   CONVFST   ;convert name typed in.
DFA7   C4 09 DE               CALL   NZ,SYNERR   ;wild cards are not allowed.
DFAA   3A F0 E3               LD   A,(CHGDRV)   ;if a change in drives was indicated,
DFAD   B7                     OR   A   ;then treat this as an unknown command
DFAE   C2 A5 E2               JP   NZ,UNKNOWN   ;which gets executed.
DFB1   CD 2E DF               CALL   SEARCH   ;else search command table for a match.
DFB4                          ; 
DFB4                          ;   Note that an unknown command returns
DFB4                          ; with (A) pointing to the last address
DFB4                          ; in our table which is (UNKNOWN).
DFB4                          ; 
DFB4   21 C1 DF               LD   HL,CMDADR   ;now, look thru our address table for command (A).
DFB7   5F                     LD   E,A   ;set (DE) to command number.
DFB8   16 00                  LD   D,0   
DFBA   19                     ADD   HL,DE   
DFBB   19                     ADD   HL,DE   ;(HL)=(CMDADR)+2*(command number).
DFBC   7E                     LD   A,(HL)   ;now pick out this address.
DFBD   23                     INC   HL   
DFBE   66                     LD   H,(HL)   
DFBF   6F                     LD   L,A   
DFC0   E9                     JP   (HL)   ;now execute it.
DFC1                          ; 
DFC1                          ;   CP/M command address table.
DFC1                          ; 
DFC1   77 E0 1F E1 5D E1 AD E1 CMDADR:   DW   DIRECT,ERASE,TYPE,SAVE   
DFC9   10 E2 8E E2 A5 E2      DW   RENAME,USER,UNKNOWN   
DFCF                          ; 
DFCF                          ;   Halt the system. Reason for this is unknown at present.
DFCF                          ; 
DFCF   21 F3 76     HALT:     LD   HL,76F3H   ;'DI HLT' instructions.
DFD2   22 00 DC               LD   (CBASE),HL   
DFD5   21 00 DC               LD   HL,CBASE   
DFD8   E9                     JP   (HL)   
DFD9                          ; 
DFD9                          ;   Read error while TYPEing a file.
DFD9                          ; 
DFD9   01 DF DF     RDERROR:   LD   BC,RDERR   
DFDC   C3 A7 DC               JP   PLINE   
DFDF   52 65 61 64 20 65 72 72 6F 72 00 RDERR:   DB   'Read error',0   
DFEA                          ; 
DFEA                          ;   Required file was not located.
DFEA                          ; 
DFEA   01 F0 DF     NONE:     LD   BC,NOFILE   
DFED   C3 A7 DC               JP   PLINE   
DFF0   4E 6F 20 66 69 6C 65 00 NOFILE:   DB   'No file',0   
DFF8                          ; 
DFF8                          ;   Decode a command of the form 'A>filename number{ filename}.
DFF8                          ; Note that a drive specifier is not allowed on the first file
DFF8                          ; name. On return, the number is in register (A). Any error
DFF8                          ; causes 'filename?' to be printed and the command is aborted.
DFF8                          ; 
DFF8   CD 5E DE     DECODE:   CALL   CONVFST   ;convert filename.
DFFB   3A F0 E3               LD   A,(CHGDRV)   ;do not allow a drive to be specified.
DFFE   B7                     OR   A   
DFFF   C2 09 DE               JP   NZ,SYNERR   
E002   21 CE E3               LD   HL,FCB+1   ;convert number now.
E005   01 0B 00               LD   BC,11   ;(B)=sum register, (C)=max digit count.
E008   7E           DECODE1:   LD   A,(HL)   
E009   FE 20                  CP   ' '   ;a space terminates the numeral.
E00B   CA 33 E0               JP   Z,DECODE3   
E00E   23                     INC   HL   
E00F   D6 30                  SUB   '0'   ;make binary from ascii.
E011   FE 0A                  CP   10   ;legal digit?
E013   D2 09 DE               JP   NC,SYNERR   
E016   57                     LD   D,A   ;yes, save it in (D).
E017   78                     LD   A,B   ;compute (B)=(B)*10 and check for overflow.
E018   E6 E0                  AND   0E0H   
E01A   C2 09 DE               JP   NZ,SYNERR   
E01D   78                     LD   A,B   
E01E   07                     RLCA   
E01F   07                     RLCA   
E020   07                     RLCA   ;(A)=(B)*8
E021   80                     ADD   A,B   ;.......*9
E022   DA 09 DE               JP   C,SYNERR   
E025   80                     ADD   A,B   ;.......*10
E026   DA 09 DE               JP   C,SYNERR   
E029   82                     ADD   A,D   ;add in new digit now.
E02A   DA 09 DE     DECODE2:   JP   C,SYNERR   
E02D   47                     LD   B,A   ;and save result.
E02E   0D                     DEC   C   ;only look at 11 digits.
E02F   C2 08 E0               JP   NZ,DECODE1   
E032   C9                     RET   
E033   7E           DECODE3:   LD   A,(HL)   ;spaces must follow (why?).
E034   FE 20                  CP   ' '   
E036   C2 09 DE               JP   NZ,SYNERR   
E039   23                     INC   HL   
E03A   0D           DECODE4:   DEC   C   
E03B   C2 33 E0               JP   NZ,DECODE3   
E03E   78                     LD   A,B   ;set (A)=the numeric value entered.
E03F   C9                     RET   
E040                          ; 
E040                          ;   Move 3 bytes from (HL) to (DE). Note that there is only
E040                          ; one reference to this at (A2D5h).
E040                          ; 
E040   06 03        MOVE3:    LD   B,3   
E042                          ; 
E042                          ;   Move (B) bytes from (HL) to (DE).
E042                          ; 
E042   7E           HL2DE:    LD   A,(HL)   
E043   12                     LD   (DE),A   
E044   23                     INC   HL   
E045   13                     INC   DE   
E046   05                     DEC   B   
E047   C2 42 E0               JP   NZ,HL2DE   
E04A   C9                     RET   
E04B                          ; 
E04B                          ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
E04B                          ; 
E04B   21 80 00     EXTRACT:   LD   HL,TBUFF   
E04E   81                     ADD   A,C   
E04F   CD 59 DE               CALL   ADDHL   
E052   7E                     LD   A,(HL)   
E053   C9                     RET   
E054                          ; 
E054                          ;  Check drive specified. If it means a change, then the new
E054                          ; drive will be selected. In any case, the drive byte of the
E054                          ; fcb will be set to null (means use current drive).
E054                          ; 
E054   AF           DSELECT:   XOR   A   ;null out first byte of fcb.
E055   32 CD E3               LD   (FCB),A   
E058   3A F0 E3               LD   A,(CHGDRV)   ;a drive change indicated?
E05B   B7                     OR   A   
E05C   C8                     RET   Z   
E05D   3D                     DEC   A   ;yes, is it the same as the current drive?
E05E   21 EF E3               LD   HL,CDRIVE   
E061   BE                     CP   (HL)   
E062   C8                     RET   Z   
E063   C3 BD DC               JP   DSKSEL   ;no. Select it then.
E066                          ; 
E066                          ;   Check the drive selection and reset it to the previous
E066                          ; drive if it was changed for the preceeding command.
E066                          ; 
E066   3A F0 E3     RESETDR:   LD   A,(CHGDRV)   ;drive change indicated?
E069   B7                     OR   A   
E06A   C8                     RET   Z   
E06B   3D                     DEC   A   ;yes, was it a different drive?
E06C   21 EF E3               LD   HL,CDRIVE   
E06F   BE                     CP   (HL)   
E070   C8                     RET   Z   
E071   3A EF E3               LD   A,(CDRIVE)   ;yes, re-select our old drive.
E074   C3 BD DC               JP   DSKSEL   
E077                          ; 
E077                          ;**************************************************************
E077                          ;*
E077                          ;*           D I R E C T O R Y   C O M M A N D
E077                          ;*
E077                          ;**************************************************************
E077                          ; 
E077   CD 5E DE     DIRECT:   CALL   CONVFST   ;convert file name.
E07A   CD 54 E0               CALL   DSELECT   ;select indicated drive.
E07D   21 CE E3               LD   HL,FCB+1   ;was any file indicated?
E080   7E                     LD   A,(HL)   
E081   FE 20                  CP   ' '   
E083   C2 8F E0               JP   NZ,DIRECT2   
E086   06 0B                  LD   B,11   ;no. Fill field with '?' - same as *.*.
E088   36 3F        DIRECT1:   LD   (HL),'?'   
E08A   23                     INC   HL   
E08B   05                     DEC   B   
E08C   C2 88 E0               JP   NZ,DIRECT1   
E08F   1E 00        DIRECT2:   LD   E,0   ;set initial cursor position.
E091   D5                     PUSH   DE   
E092   CD E9 DC               CALL   SRCHFCB   ;get first file name.
E095   CC EA DF               CALL   Z,NONE   ;none found at all?
E098   CA 1B E1     DIRECT3:   JP   Z,DIRECT9   ;terminate if no more names.
E09B   3A EE E3               LD   A,(RTNCODE)   ;get file's position in segment (0-3).
E09E   0F                     RRCA   
E09F   0F                     RRCA   
E0A0   0F                     RRCA   
E0A1   E6 60                  AND   60H   ;(A)=position*32
E0A3   4F                     LD   C,A   
E0A4   3E 0A                  LD   A,10   
E0A6   CD 4B E0               CALL   EXTRACT   ;extract the tenth entry in fcb.
E0A9   17                     RLA   ;check system file status bit.
E0AA   DA 0F E1               JP   C,DIRECT8   ;we don't list them.
E0AD   D1                     POP   DE   
E0AE   7B                     LD   A,E   ;bump name count.
E0AF   1C                     INC   E   
E0B0   D5                     PUSH   DE   
E0B1   E6 03                  AND   03H   ;at end of line?
E0B3   F5                     PUSH   AF   
E0B4   C2 CC E0               JP   NZ,DIRECT4   
E0B7   CD 98 DC               CALL   CRLF   ;yes, end this line and start another.
E0BA   C5                     PUSH   BC   
E0BB   CD D0 DD               CALL   GETDSK   ;start line with ('A:').
E0BE   C1                     POP   BC   
E0BF   C6 41                  ADD   A,'A'   
E0C1   CD 92 DC               CALL   PRINTB   
E0C4   3E 3A                  LD   A,':'   
E0C6   CD 92 DC               CALL   PRINTB   
E0C9   C3 D4 E0               JP   DIRECT5   
E0CC   CD A2 DC     DIRECT4:   CALL   SPACE   ;add seperator between file names.
E0CF   3E 3A                  LD   A,':'   
E0D1   CD 92 DC               CALL   PRINTB   
E0D4   CD A2 DC     DIRECT5:   CALL   SPACE   
E0D7   06 01                  LD   B,1   ;'extract' each file name character at a time.
E0D9   78           DIRECT6:   LD   A,B   
E0DA   CD 4B E0               CALL   EXTRACT   
E0DD   E6 7F                  AND   7FH   ;strip bit 7 (status bit).
E0DF   FE 20                  CP   ' '   ;are we at the end of the name?
E0E1   C2 F9 E0               JP   NZ,DRECT65   
E0E4   F1                     POP   AF   ;yes, don't print spaces at the end of a line.
E0E5   F5                     PUSH   AF   
E0E6   FE 03                  CP   3   
E0E8   C2 F7 E0               JP   NZ,DRECT63   
E0EB   3E 09                  LD   A,9   ;first check for no extension.
E0ED   CD 4B E0               CALL   EXTRACT   
E0F0   E6 7F                  AND   7FH   
E0F2   FE 20                  CP   ' '   
E0F4   CA 0E E1               JP   Z,DIRECT7   ;don't print spaces.
E0F7   3E 20        DRECT63:   LD   A,' '   ;else print them.
E0F9   CD 92 DC     DRECT65:   CALL   PRINTB   
E0FC   04                     INC   B   ;bump to next character psoition.
E0FD   78                     LD   A,B   
E0FE   FE 0C                  CP   12   ;end of the name?
E100   D2 0E E1               JP   NC,DIRECT7   
E103   FE 09                  CP   9   ;nope, starting extension?
E105   C2 D9 E0               JP   NZ,DIRECT6   
E108   CD A2 DC               CALL   SPACE   ;yes, add seperating space.
E10B   C3 D9 E0               JP   DIRECT6   
E10E   F1           DIRECT7:   POP   AF   ;get the next file name.
E10F   CD C2 DD     DIRECT8:   CALL   CHKCON   ;first check console, quit on anything.
E112   C2 1B E1               JP   NZ,DIRECT9   
E115   CD E4 DC               CALL   SRCHNXT   ;get next name.
E118   C3 98 E0               JP   DIRECT3   ;and continue with our list.
E11B   D1           DIRECT9:   POP   DE   ;restore the stack and return to command level.
E11C   C3 86 E3               JP   GETBACK   
E11F                          ; 
E11F                          ;**************************************************************
E11F                          ;*
E11F                          ;*                E R A S E   C O M M A N D
E11F                          ;*
E11F                          ;**************************************************************
E11F                          ; 
E11F   CD 5E DE     ERASE:    CALL   CONVFST   ;convert file name.
E122   FE 0B                  CP   11   ;was '*.*' entered?
E124   C2 42 E1               JP   NZ,ERASE1   
E127   01 52 E1               LD   BC,YESNO   ;yes, ask for confirmation.
E12A   CD A7 DC               CALL   PLINE   
E12D   CD 39 DD               CALL   GETINP   
E130   21 07 DC               LD   HL,INBUFF+1   
E133   35                     DEC   (HL)   ;must be exactly 'y'.
E134   C2 82 DF               JP   NZ,CMMND1   
E137   23                     INC   HL   
E138   7E                     LD   A,(HL)   
E139   FE 59                  CP   'Y'   
E13B   C2 82 DF               JP   NZ,CMMND1   
E13E   23                     INC   HL   
E13F   22 88 DC               LD   (INPOINT),HL   ;save input line pointer.
E142   CD 54 E0     ERASE1:   CALL   DSELECT   ;select desired disk.
E145   11 CD E3               LD   DE,FCB   
E148   CD EF DC               CALL   DELETE   ;delete the file.
E14B   3C                     INC   A   
E14C   CC EA DF               CALL   Z,NONE   ;not there?
E14F   C3 86 E3               JP   GETBACK   ;return to command level now.
E152   41 6C 6C 20 28 79 2F 6E 29 3F 00 YESNO:   DB   'All (y/n)?',0   
E15D                          ; 
E15D                          ;**************************************************************
E15D                          ;*
E15D                          ;*            T Y P E   C O M M A N D
E15D                          ;*
E15D                          ;**************************************************************
E15D                          ; 
E15D   CD 5E DE     TYPE:     CALL   CONVFST   ;convert file name.
E160   C2 09 DE               JP   NZ,SYNERR   ;wild cards not allowed.
E163   CD 54 E0               CALL   DSELECT   ;select indicated drive.
E166   CD D0 DC               CALL   OPENFCB   ;open the file.
E169   CA A7 E1               JP   Z,TYPE5   ;not there?
E16C   CD 98 DC               CALL   CRLF   ;ok, start a new line on the screen.
E16F   21 F1 E3               LD   HL,NBYTES   ;initialize byte counter.
E172   36 FF                  LD   (HL),0FFH   ;set to read first sector.
E174   21 F1 E3     TYPE1:    LD   HL,NBYTES   
E177   7E           TYPE2:    LD   A,(HL)   ;have we written the entire sector?
E178   FE 80                  CP   128   
E17A   DA 87 E1               JP   C,TYPE3   
E17D   E5                     PUSH   HL   ;yes, read in the next one.
E17E   CD FE DC               CALL   READFCB   
E181   E1                     POP   HL   
E182   C2 A0 E1               JP   NZ,TYPE4   ;end or error?
E185   AF                     XOR   A   ;ok, clear byte counter.
E186   77                     LD   (HL),A   
E187   34           TYPE3:    INC   (HL)   ;count this byte.
E188   21 80 00               LD   HL,TBUFF   ;and get the (A)th one from the buffer (TBUFF).
E18B   CD 59 DE               CALL   ADDHL   
E18E   7E                     LD   A,(HL)   
E18F   FE 1A                  CP   CNTRLZ   ;end of file mark?
E191   CA 86 E3               JP   Z,GETBACK   
E194   CD 8C DC               CALL   PRINT   ;no, print it.
E197   CD C2 DD               CALL   CHKCON   ;check console, quit if anything ready.
E19A   C2 86 E3               JP   NZ,GETBACK   
E19D   C3 74 E1               JP   TYPE1   
E1A0                          ; 
E1A0                          ;   Get here on an end of file or read error.
E1A0                          ; 
E1A0   3D           TYPE4:    DEC   A   ;read error?
E1A1   CA 86 E3               JP   Z,GETBACK   
E1A4   CD D9 DF               CALL   RDERROR   ;yes, print message.
E1A7   CD 66 E0     TYPE5:    CALL   RESETDR   ;and reset proper drive
E1AA   C3 09 DE               JP   SYNERR   ;now print file name with problem.
E1AD                          ; 
E1AD                          ;**************************************************************
E1AD                          ;*
E1AD                          ;*            S A V E   C O M M A N D
E1AD                          ;*
E1AD                          ;**************************************************************
E1AD                          ; 
E1AD   CD F8 DF     SAVE:     CALL   DECODE   ;get numeric number that follows SAVE.
E1B0   F5                     PUSH   AF   ;save number of pages to write.
E1B1   CD 5E DE               CALL   CONVFST   ;convert file name.
E1B4   C2 09 DE               JP   NZ,SYNERR   ;wild cards not allowed.
E1B7   CD 54 E0               CALL   DSELECT   ;select specified drive.
E1BA   11 CD E3               LD   DE,FCB   ;now delete this file.
E1BD   D5                     PUSH   DE   
E1BE   CD EF DC               CALL   DELETE   
E1C1   D1                     POP   DE   
E1C2   CD 09 DD               CALL   CREATE   ;and create it again.
E1C5   CA FB E1               JP   Z,SAVE3   ;can't create?
E1C8   AF                     XOR   A   ;clear record number byte.
E1C9   32 ED E3               LD   (FCB+32),A   
E1CC   F1                     POP   AF   ;convert pages to sectors.
E1CD   6F                     LD   L,A   
E1CE   26 00                  LD   H,0   
E1D0   29                     ADD   HL,HL   ;(HL)=number of sectors to write.
E1D1   11 00 01               LD   DE,TBASE   ;and we start from here.
E1D4   7C           SAVE1:    LD   A,H   ;done yet?
E1D5   B5                     OR   L   
E1D6   CA F1 E1               JP   Z,SAVE2   
E1D9   2B                     DEC   HL   ;nope, count this and compute the start
E1DA   E5                     PUSH   HL   ;of the next 128 byte sector.
E1DB   21 80 00               LD   HL,128   
E1DE   19                     ADD   HL,DE   
E1DF   E5                     PUSH   HL   ;save it and set the transfer address.
E1E0   CD D8 DD               CALL   DMASET   
E1E3   11 CD E3               LD   DE,FCB   ;write out this sector now.
E1E6   CD 04 DD               CALL   WRTREC   
E1E9   D1                     POP   DE   ;reset (DE) to the start of the last sector.
E1EA   E1                     POP   HL   ;restore sector count.
E1EB   C2 FB E1               JP   NZ,SAVE3   ;write error?
E1EE   C3 D4 E1               JP   SAVE1   
E1F1                          ; 
E1F1                          ;   Get here after writing all of the file.
E1F1                          ; 
E1F1   11 CD E3     SAVE2:    LD   DE,FCB   ;now close the file.
E1F4   CD DA DC               CALL   CLOSE   
E1F7   3C                     INC   A   ;did it close ok?
E1F8   C2 01 E2               JP   NZ,SAVE4   
E1FB                          ; 
E1FB                          ;   Print out error message (no space).
E1FB                          ; 
E1FB   01 07 E2     SAVE3:    LD   BC,NOSPACE   
E1FE   CD A7 DC               CALL   PLINE   
E201   CD D5 DD     SAVE4:    CALL   STDDMA   ;reset the standard dma address.
E204   C3 86 E3               JP   GETBACK   
E207   4E 6F 20 73 70 61 63 65 00 NOSPACE:   DB   'No space',0   
E210                          ; 
E210                          ;**************************************************************
E210                          ;*
E210                          ;*           R E N A M E   C O M M A N D
E210                          ;*
E210                          ;**************************************************************
E210                          ; 
E210   CD 5E DE     RENAME:   CALL   CONVFST   ;convert first file name.
E213   C2 09 DE               JP   NZ,SYNERR   ;wild cards not allowed.
E216   3A F0 E3               LD   A,(CHGDRV)   ;remember any change in drives specified.
E219   F5                     PUSH   AF   
E21A   CD 54 E0               CALL   DSELECT   ;and select this drive.
E21D   CD E9 DC               CALL   SRCHFCB   ;is this file present?
E220   C2 79 E2               JP   NZ,RENAME6   ;yes, print error message.
E223   21 CD E3               LD   HL,FCB   ;yes, move this name into second slot.
E226   11 DD E3               LD   DE,FCB+16   
E229   06 10                  LD   B,16   
E22B   CD 42 E0               CALL   HL2DE   
E22E   2A 88 DC               LD   HL,(INPOINT)   ;get input pointer.
E231   EB                     EX   DE,HL   
E232   CD 4F DE               CALL   NONBLANK   ;get next non blank character.
E235   FE 3D                  CP   '='   ;only allow an '=' or '_' seperator.
E237   CA 3F E2               JP   Z,RENAME1   
E23A   FE 5F                  CP   '_'   
E23C   C2 73 E2               JP   NZ,RENAME5   
E23F   EB           RENAME1:   EX   DE,HL   
E240   23                     INC   HL   ;ok, skip seperator.
E241   22 88 DC               LD   (INPOINT),HL   ;save input line pointer.
E244   CD 5E DE               CALL   CONVFST   ;convert this second file name now.
E247   C2 73 E2               JP   NZ,RENAME5   ;again, no wild cards.
E24A   F1                     POP   AF   ;if a drive was specified, then it
E24B   47                     LD   B,A   ;must be the same as before.
E24C   21 F0 E3               LD   HL,CHGDRV   
E24F   7E                     LD   A,(HL)   
E250   B7                     OR   A   
E251   CA 59 E2               JP   Z,RENAME2   
E254   B8                     CP   B   
E255   70                     LD   (HL),B   
E256   C2 73 E2               JP   NZ,RENAME5   ;they were different, error.
E259   70           RENAME2:   LD   (HL),B   ;	reset as per the first file specification.
E25A   AF                     XOR   A   
E25B   32 CD E3               LD   (FCB),A   ;clear the drive byte of the fcb.
E25E   CD E9 DC     RENAME3:   CALL   SRCHFCB   ;and go look for second file.
E261   CA 6D E2               JP   Z,RENAME4   ;doesn't exist?
E264   11 CD E3               LD   DE,FCB   
E267   CD 0E DD               CALL   RENAM   ;ok, rename the file.
E26A   C3 86 E3               JP   GETBACK   
E26D                          ; 
E26D                          ;   Process rename errors here.
E26D                          ; 
E26D   CD EA DF     RENAME4:   CALL   NONE   ;file not there.
E270   C3 86 E3               JP   GETBACK   
E273   CD 66 E0     RENAME5:   CALL   RESETDR   ;bad command format.
E276   C3 09 DE               JP   SYNERR   
E279   01 82 E2     RENAME6:   LD   BC,EXISTS   ;destination file already exists.
E27C   CD A7 DC               CALL   PLINE   
E27F   C3 86 E3               JP   GETBACK   
E282   46 69 6C 65 20 65 78 69 73 74 73 00 EXISTS:   DB   'File exists',0   
E28E                          ; 
E28E                          ;**************************************************************
E28E                          ;*
E28E                          ;*             U S E R   C O M M A N D
E28E                          ;*
E28E                          ;**************************************************************
E28E                          ; 
E28E   CD F8 DF     USER:     CALL   DECODE   ;get numeric value following command.
E291   FE 10                  CP   16   ;legal user number?
E293   D2 09 DE               JP   NC,SYNERR   
E296   5F                     LD   E,A   ;yes but is there anything else?
E297   3A CE E3               LD   A,(FCB+1)   
E29A   FE 20                  CP   ' '   
E29C   CA 09 DE               JP   Z,SYNERR   ;yes, that is not allowed.
E29F   CD 15 DD               CALL   GETSETUC   ;ok, set user code.
E2A2   C3 89 E3               JP   GETBACK1   
E2A5                          ; 
E2A5                          ;**************************************************************
E2A5                          ;*
E2A5                          ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
E2A5                          ;*
E2A5                          ;**************************************************************
E2A5                          ; 
E2A5   CD F5 DD     UNKNOWN:   CALL   VERIFY   ;check for valid system (why?).
E2A8   3A CE E3               LD   A,(FCB+1)   ;anything to execute?
E2AB   FE 20                  CP   ' '   
E2AD   C2 C4 E2               JP   NZ,UNKWN1   
E2B0   3A F0 E3               LD   A,(CHGDRV)   ;nope, only a drive change?
E2B3   B7                     OR   A   
E2B4   CA 89 E3               JP   Z,GETBACK1   ;neither???
E2B7   3D                     DEC   A   
E2B8   32 EF E3               LD   (CDRIVE),A   ;ok, store new drive.
E2BB   CD 29 DD               CALL   MOVECD   ;set (TDRIVE) also.
E2BE   CD BD DC               CALL   DSKSEL   ;and select this drive.
E2C1   C3 89 E3               JP   GETBACK1   ;then return.
E2C4                          ; 
E2C4                          ;   Here a file name was typed. Prepare to execute it.
E2C4                          ; 
E2C4   11 D6 E3     UNKWN1:   LD   DE,FCB+9   ;an extension specified?
E2C7   1A                     LD   A,(DE)   
E2C8   FE 20                  CP   ' '   
E2CA   C2 09 DE               JP   NZ,SYNERR   ;yes, not allowed.
E2CD   D5           UNKWN2:   PUSH   DE   
E2CE   CD 54 E0               CALL   DSELECT   ;select specified drive.
E2D1   D1                     POP   DE   
E2D2   21 83 E3               LD   HL,COMFILE   ;set the extension to 'COM'.
E2D5   CD 40 E0               CALL   MOVE3   
E2D8   CD D0 DC               CALL   OPENFCB   ;and open this file.
E2DB   CA 6B E3               JP   Z,UNKWN9   ;not present?
E2DE                          ; 
E2DE                          ;   Load in the program.
E2DE                          ; 
E2DE   21 00 01               LD   HL,TBASE   ;store the program starting here.
E2E1   E5           UNKWN3:   PUSH   HL   
E2E2   EB                     EX   DE,HL   
E2E3   CD D8 DD               CALL   DMASET   ;set transfer address.
E2E6   11 CD E3               LD   DE,FCB   ;and read the next record.
E2E9   CD F9 DC               CALL   RDREC   
E2EC   C2 01 E3               JP   NZ,UNKWN4   ;end of file or read error?
E2EF   E1                     POP   HL   ;nope, bump pointer for next sector.
E2F0   11 80 00               LD   DE,128   
E2F3   19                     ADD   HL,DE   
E2F4   11 00 DC               LD   DE,CBASE   ;enough room for the whole file?
E2F7   7D                     LD   A,L   
E2F8   93                     SUB   E   
E2F9   7C                     LD   A,H   
E2FA   9A                     SBC   A,D   
E2FB   D2 71 E3               JP   NC,UNKWN0   ;no, it can't fit.
E2FE   C3 E1 E2               JP   UNKWN3   
E301                          ; 
E301                          ;   Get here after finished reading.
E301                          ; 
E301   E1           UNKWN4:   POP   HL   
E302   3D                     DEC   A   ;normal end of file?
E303   C2 71 E3               JP   NZ,UNKWN0   
E306   CD 66 E0               CALL   RESETDR   ;yes, reset previous drive.
E309   CD 5E DE               CALL   CONVFST   ;convert the first file name that follows
E30C   21 F0 E3               LD   HL,CHGDRV   ;command name.
E30F   E5                     PUSH   HL   
E310   7E                     LD   A,(HL)   ;set drive code in default fcb.
E311   32 CD E3               LD   (FCB),A   
E314   3E 10                  LD   A,16   ;put second name 16 bytes later.
E316   CD 60 DE               CALL   CONVERT   ;convert second file name.
E319   E1                     POP   HL   
E31A   7E                     LD   A,(HL)   ;and set the drive for this second file.
E31B   32 DD E3               LD   (FCB+16),A   
E31E   AF                     XOR   A   ;clear record byte in fcb.
E31F   32 ED E3               LD   (FCB+32),A   
E322   11 5C 00               LD   DE,TFCB   ;move it into place at(005Ch).
E325   21 CD E3               LD   HL,FCB   
E328   06 21                  LD   B,33   
E32A   CD 42 E0               CALL   HL2DE   
E32D   21 08 DC               LD   HL,INBUFF+2   ;now move the remainder of the input
E330   7E           UNKWN5:   LD   A,(HL)   ;line down to (0080h). Look for a non blank.
E331   B7                     OR   A   ;or a null.
E332   CA 3E E3               JP   Z,UNKWN6   
E335   FE 20                  CP   ' '   
E337   CA 3E E3               JP   Z,UNKWN6   
E33A   23                     INC   HL   
E33B   C3 30 E3               JP   UNKWN5   
E33E                          ; 
E33E                          ;   Do the line move now. It ends in a null byte.
E33E                          ; 
E33E   06 00        UNKWN6:   LD   B,0   ;keep a character count.
E340   11 81 00               LD   DE,TBUFF+1   ;data gets put here.
E343   7E           UNKWN7:   LD   A,(HL)   ;move it now.
E344   12                     LD   (DE),A   
E345   B7                     OR   A   
E346   CA 4F E3               JP   Z,UNKWN8   
E349   04                     INC   B   
E34A   23                     INC   HL   
E34B   13                     INC   DE   
E34C   C3 43 E3               JP   UNKWN7   
E34F   78           UNKWN8:   LD   A,B   ;now store the character count.
E350   32 80 00               LD   (TBUFF),A   
E353   CD 98 DC               CALL   CRLF   ;clean up the screen.
E356   CD D5 DD               CALL   STDDMA   ;set standard transfer address.
E359   CD 1A DD               CALL   SETCDRV   ;reset current drive.
E35C   CD 00 01               CALL   TBASE   ;and execute the program.
E35F                          ; 
E35F                          ;   Transiant programs return here (or reboot).
E35F                          ; 
E35F   31 AB E3               LD   SP,BATCH   ;set stack first off.
E362   CD 29 DD               CALL   MOVECD   ;move current drive into place (TDRIVE).
E365   CD BD DC               CALL   DSKSEL   ;and reselect it.
E368   C3 82 DF               JP   CMMND1   ;back to comand mode.
E36B                          ; 
E36B                          ;   Get here if some error occured.
E36B                          ; 
E36B   CD 66 E0     UNKWN9:   CALL   RESETDR   ;inproper format.
E36E   C3 09 DE               JP   SYNERR   
E371   01 7A E3     UNKWN0:   LD   BC,BADLOAD   ;read error or won't fit.
E374   CD A7 DC               CALL   PLINE   
E377   C3 86 E3               JP   GETBACK   
E37A   42 61 64 20 6C 6F 61 64 00 BADLOAD:   DB   'Bad load',0   
E383   43 4F 4D     COMFILE:   DB   'COM'   ;command file extension.
E386                          ; 
E386                          ;   Get here to return to command level. We will reset the
E386                          ; previous active drive and then either return to command
E386                          ; level directly or print error message and then return.
E386                          ; 
E386   CD 66 E0     GETBACK:   CALL   RESETDR   ;reset previous drive.
E389   CD 5E DE     GETBACK1:   CALL   CONVFST   ;convert first name in (FCB).
E38C   3A CE E3               LD   A,(FCB+1)   ;if this was just a drive change request,
E38F   D6 20                  SUB   ' '   ;make sure it was valid.
E391   21 F0 E3               LD   HL,CHGDRV   
E394   B6                     OR   (HL)   
E395   C2 09 DE               JP   NZ,SYNERR   
E398   C3 82 DF               JP   CMMND1   ;ok, return to command level.
E39B                          ; 
E39B                          ;   ccp stack area.
E39B                          ; 
E39B   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
E3AB                CCPSTACK:   EQU   $   
E3AB                          ; 
E3AB                          ;   Batch (or SUBMIT) processing information storage.
E3AB                          ; 
E3AB   00           BATCH:    DB   0   ;batch mode flag (0=not active).
E3AC   00 24 24 24 20 20 20 20 20 53 55 42 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 BATCHFCB:   DB   0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
E3CD                          ; 
E3CD                          ;   File control block setup by the CCP.
E3CD                          ; 
E3CD   00 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 FCB:   DB   0,'           ',0,0,0,0,0,'           ',0,0,0,0,0   
E3EE   00           RTNCODE:   DB   0   ;status returned from bdos call.
E3EF   00           CDRIVE:   DB   0   ;currently active drive.
E3F0   00           CHGDRV:   DB   0   ;change in drives flag (0=no change).
E3F1   00 00        NBYTES:   DW   0   ;byte counter used by TYPE.
E3F3                          ; 
E3F3                          ;   Room for expansion?
E3F3                          ; 
E3F3   00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0   
E400                          ; 
E400                          ;   Note that the following six bytes must match those at
E400                          ; (PATTRN1) or cp/m will HALT. Why?
E400                          ; 
E400   00 16 00 00 00 00 PATTRN2:   DB   0,22,0,0,0,0   ;(* serial number bytes *).
E406                          ; 
E406                          ;**************************************************************
E406                          ;*
E406                          ;*                    B D O S   E N T R Y
E406                          ;*
E406                          ;**************************************************************
E406                          ; 
E406   C3 11 E4     FBASE:    JP   FBASE1   
E409                          ; 
E409                          ;   Bdos error table.
E409                          ; 
E409   99 E4        BADSCTR:   DW   ERROR1   ;bad sector on read or write.
E40B   A5 E4        BADSLCT:   DW   ERROR2   ;bad disk select.
E40D   AB E4        RODISK:   DW   ERROR3   ;disk is read only.
E40F   B1 E4        ROFILE:   DW   ERROR4   ;file is read only.
E411                          ; 
E411                          ;   Entry into bdos. (DE) or (E) are the parameters passed. The
E411                          ; function number desired is in register (C).
E411                          ; 
E411   EB           FBASE1:   EX   DE,HL   ;save the (DE) parameters.
E412   22 43 E7               LD   (PARAMS),HL   
E415   EB                     EX   DE,HL   
E416   7B                     LD   A,E   ;and save register (E) in particular.
E417   32 D8 F1               LD   (EPARAM),A   
E41A   21 00 00               LD   HL,0   
E41D   22 45 E7               LD   (STATUS),HL   ;clear return status.
E420   39                     ADD   HL,SP   
E421   22 0F E7               LD   (USRSTACK),HL   ;save users stack pointer.
E424   31 41 E7               LD   SP,STKAREA   ;and set our own.
E427   AF                     XOR   A   ;clear auto select storage space.
E428   32 E2 F1               LD   (AUTOFLAG),A   
E42B   32 E0 F1               LD   (AUTO),A   
E42E   21 76 F1               LD   HL,GOBACK   ;set return address.
E431   E5                     PUSH   HL   
E432   79                     LD   A,C   ;get function number.
E433   FE 29                  CP   NFUNCTS   ;valid function number?
E435   D0                     RET   NC   
E436   4B                     LD   C,E   ;keep single register function here.
E437   21 47 E4               LD   HL,FUNCTNS   ;now look thru the function table.
E43A   5F                     LD   E,A   
E43B   16 00                  LD   D,0   ;(DE)=function number.
E43D   19                     ADD   HL,DE   
E43E   19                     ADD   HL,DE   ;(HL)=(start of table)+2*(function number).
E43F   5E                     LD   E,(HL)   
E440   23                     INC   HL   
E441   56                     LD   D,(HL)   ;now (DE)=address for this function.
E442   2A 43 E7               LD   HL,(PARAMS)   ;retrieve parameters.
E445   EB                     EX   DE,HL   ;now (DE) has the original parameters.
E446   E9                     JP   (HL)   ;execute desired function.
E447                          ; 
E447                          ;   BDOS function jump table.
E447                          ; 
E447                NFUNCTS:   EQU   41   
E447                          ; 
E447   03 F2 C8 E6 90 E5 CE E6 12 F2 0F F2 D4 E6 ED E6 FUNCTNS:   DW   WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB   
E457   F3 E6 F8 E6 E1 E5 FE E6 80 F0 85 F0 47 F0 9E F0 DW   SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL   
E467   A7 F0 AD F0 CA F0 D9 F0 E2 F0 E8 F0 EE F0 DW   CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE   
E475   F7 F0 00 F1 06 F1 0C F1 13 F1 2E E9 19 F1 1F F1 DW   RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR   
E485   28 F1 2F F1 43 F1 49 F1 4F F1 10 F0 55 F1 04 E7 DW   GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN   
E495   04 E7 9D F1            DW   RTN,WTSPECL   
E499                          ; 
E499                          ;   Bdos error message section.
E499                          ; 
E499   21 CA E4     ERROR1:   LD   HL,BADSEC   ;bad sector message.
E49C   CD E5 E4               CALL   PRTERR   ;print it and get a 1 char responce.
E49F   FE 03                  CP   CNTRLC   ;re-boot request (control-c)?
E4A1   CA 00 00               JP   Z,0   ;yes.
E4A4   C9                     RET   ;no, return to retry i/o function.
E4A5                          ; 
E4A5   21 D5 E4     ERROR2:   LD   HL,BADSEL   ;bad drive selected.
E4A8   C3 B4 E4               JP   ERROR5   
E4AB                          ; 
E4AB   21 E1 E4     ERROR3:   LD   HL,DISKRO   ;disk is read only.
E4AE   C3 B4 E4               JP   ERROR5   
E4B1                          ; 
E4B1   21 DC E4     ERROR4:   LD   HL,FILERO   ;file is read only.
E4B4                          ; 
E4B4   CD E5 E4     ERROR5:   CALL   PRTERR   
E4B7   C3 00 00               JP   0   ;always reboot on these errors.
E4BA                          ; 
E4BA   42 64 6F 73 20 45 72 72 20 4F 6E 20 BDOSERR:   DB   'Bdos Err On '   
E4C6   20 3A 20 24  BDOSDRV:   DB   ' : $'   
E4CA   42 61 64 20 53 65 63 74 6F 72 24 BADSEC:   DB   'Bad Sector$'   
E4D5   53 65 6C 65 63 74 24 BADSEL:   DB   'Select$'   
E4DC   46 69 6C 65 20 FILERO:   DB   'File '   
E4E1   52 2F 4F 24  DISKRO:   DB   'R/O$'   
E4E5                          ; 
E4E5                          ;   Print bdos error message.
E4E5                          ; 
E4E5   E5           PRTERR:   PUSH   HL   ;save second message pointer.
E4E6   CD C9 E5               CALL   OUTCRLF   ;send (cr)(lf).
E4E9   3A 42 E7               LD   A,(ACTIVE)   ;get active drive.
E4EC   C6 41                  ADD   A,'A'   ;make ascii.
E4EE   32 C6 E4               LD   (BDOSDRV),A   ;and put in message.
E4F1   01 BA E4               LD   BC,BDOSERR   ;and print it.
E4F4   CD D3 E5               CALL   PRTMESG   
E4F7   C1                     POP   BC   ;print second message line now.
E4F8   CD D3 E5               CALL   PRTMESG   
E4FB                          ; 
E4FB                          ;   Get an input character. We will check our 1 character
E4FB                          ; buffer first. This may be set by the console status routine.
E4FB                          ; 
E4FB   21 0E E7     GETCHAR:   LD   HL,CHARBUF   ;check character buffer.
E4FE   7E                     LD   A,(HL)   ;anything present already?
E4FF   36 00                  LD   (HL),0   ;...either case clear it.
E501   B7                     OR   A   
E502   C0                     RET   NZ   ;yes, use it.
E503   C3 09 F2               JP   CONIN   ;nope, go get a character responce.
E506                          ; 
E506                          ;   Input and echo a character.
E506                          ; 
E506   CD FB E4     GETECHO:   CALL   GETCHAR   ;input a character.
E509   CD 14 E5               CALL   CHKCHAR   ;carriage control?
E50C   D8                     RET   C   ;no, a regular control char so don't echo.
E50D   F5                     PUSH   AF   ;ok, save character now.
E50E   4F                     LD   C,A   
E50F   CD 90 E5               CALL   OUTCON   ;and echo it.
E512   F1                     POP   AF   ;get character and return.
E513   C9                     RET   
E514                          ; 
E514                          ;   Check character in (A). Set the zero flag on a carriage
E514                          ; control character and the carry flag on any other control
E514                          ; character.
E514                          ; 
E514   FE 0D        CHKCHAR:   CP   CR   ;check for carriage return, line feed, backspace,
E516   C8                     RET   Z   ;or a tab.
E517   FE 0A                  CP   LF   
E519   C8                     RET   Z   
E51A   FE 09                  CP   TAB   
E51C   C8                     RET   Z   
E51D   FE 08                  CP   BS   
E51F   C8                     RET   Z   
E520   FE 20                  CP   ' '   ;other control char? Set carry flag.
E522   C9                     RET   
E523                          ; 
E523                          ;   Check the console during output. Halt on a control-s, then
E523                          ; reboot on a control-c. If anything else is ready, clear the
E523                          ; zero flag and return (the calling routine may want to do
E523                          ; something).
E523                          ; 
E523   3A 0E E7     CKCONSOL:   LD   A,(CHARBUF)   ;check buffer.
E526   B7                     OR   A   ;if anything, just return without checking.
E527   C2 45 E5               JP   NZ,CKCON2   
E52A   CD 06 F2               CALL   CONST   ;nothing in buffer. Check console.
E52D   E6 01                  AND   01H   ;look at bit 0.
E52F   C8                     RET   Z   ;return if nothing.
E530   CD 09 F2               CALL   CONIN   ;ok, get it.
E533   FE 13                  CP   CNTRLS   ;if not control-s, return with zero cleared.
E535   C2 42 E5               JP   NZ,CKCON1   
E538   CD 09 F2               CALL   CONIN   ;halt processing until another char
E53B   FE 03                  CP   CNTRLC   ;is typed. Control-c?
E53D   CA 00 00               JP   Z,0   ;yes, reboot now.
E540   AF                     XOR   A   ;no, just pretend nothing was ever ready.
E541   C9                     RET   
E542   32 0E E7     CKCON1:   LD   (CHARBUF),A   ;save character in buffer for later processing.
E545   3E 01        CKCON2:   LD   A,1   ;set (A) to non zero to mean something is ready.
E547   C9                     RET   
E548                          ; 
E548                          ;   Output (C) to the screen. If the printer flip-flop flag
E548                          ; is set, we will send character to printer also. The console
E548                          ; will be checked in the process.
E548                          ; 
E548   3A 0A E7     OUTCHAR:   LD   A,(OUTFLAG)   ;check output flag.
E54B   B7                     OR   A   ;anything and we won't generate output.
E54C   C2 62 E5               JP   NZ,OUTCHR1   
E54F   C5                     PUSH   BC   
E550   CD 23 E5               CALL   CKCONSOL   ;check console (we don't care whats there).
E553   C1                     POP   BC   
E554   C5                     PUSH   BC   
E555   CD 0C F2               CALL   CONOUT   ;output (C) to the screen.
E558   C1                     POP   BC   
E559   C5                     PUSH   BC   
E55A   3A 0D E7               LD   A,(PRTFLAG)   ;check printer flip-flop flag.
E55D   B7                     OR   A   
E55E   C4 0F F2               CALL   NZ,LIST   ;print it also if non-zero.
E561   C1                     POP   BC   
E562   79           OUTCHR1:   LD   A,C   ;update cursors position.
E563   21 0C E7               LD   HL,CURPOS   
E566   FE 7F                  CP   DEL   ;rubouts don't do anything here.
E568   C8                     RET   Z   
E569   34                     INC   (HL)   ;bump line pointer.
E56A   FE 20                  CP   ' '   ;and return if a normal character.
E56C   D0                     RET   NC   
E56D   35                     DEC   (HL)   ;restore and check for the start of the line.
E56E   7E                     LD   A,(HL)   
E56F   B7                     OR   A   
E570   C8                     RET   Z   ;ingnore control characters at the start of the line.
E571   79                     LD   A,C   
E572   FE 08                  CP   BS   ;is it a backspace?
E574   C2 79 E5               JP   NZ,OUTCHR2   
E577   35                     DEC   (HL)   ;yes, backup pointer.
E578   C9                     RET   
E579   FE 0A        OUTCHR2:   CP   LF   ;is it a line feed?
E57B   C0                     RET   NZ   ;ignore anything else.
E57C   36 00                  LD   (HL),0   ;reset pointer to start of line.
E57E   C9                     RET   
E57F                          ; 
E57F                          ;   Output (A) to the screen. If it is a control character
E57F                          ; (other than carriage control), use ^x format.
E57F                          ; 
E57F   79           SHOWIT:   LD   A,C   
E580   CD 14 E5               CALL   CHKCHAR   ;check character.
E583   D2 90 E5               JP   NC,OUTCON   ;not a control, use normal output.
E586   F5                     PUSH   AF   
E587   0E 5E                  LD   C,'^'   ;for a control character, preceed it with '^'.
E589   CD 48 E5               CALL   OUTCHAR   
E58C   F1                     POP   AF   
E58D   F6 40                  OR   '@'   ;and then use the letter equivelant.
E58F   4F                     LD   C,A   
E590                          ; 
E590                          ;   Function to output (C) to the console device and expand tabs
E590                          ; if necessary.
E590                          ; 
E590   79           OUTCON:   LD   A,C   
E591   FE 09                  CP   TAB   ;is it a tab?
E593   C2 48 E5               JP   NZ,OUTCHAR   ;use regular output.
E596   0E 20        OUTCON1:   LD   C,' '   ;yes it is, use spaces instead.
E598   CD 48 E5               CALL   OUTCHAR   
E59B   3A 0C E7               LD   A,(CURPOS)   ;go until the cursor is at a multiple of 8
E59E   E6 07                  AND   07H   ;position.
E5A0   C2 96 E5               JP   NZ,OUTCON1   
E5A3   C9                     RET   
E5A4                          ; 
E5A4                          ;   Echo a backspace character. Erase the prevoius character
E5A4                          ; on the screen.
E5A4                          ; 
E5A4   CD AC E5     BACKUP:   CALL   BACKUP1   ;backup the screen 1 place.
E5A7   0E 20                  LD   C,' '   ;then blank that character.
E5A9   CD 0C F2               CALL   CONOUT   
E5AC   0E 08        BACKUP1:   LD   C,BS   ;then back space once more.
E5AE   C3 0C F2               JP   CONOUT   
E5B1                          ; 
E5B1                          ;   Signal a deleted line. Print a '#' at the end and start
E5B1                          ; over.
E5B1                          ; 
E5B1   0E 23        NEWLINE:   LD   C,'#'   
E5B3   CD 48 E5               CALL   OUTCHAR   ;print this.
E5B6   CD C9 E5               CALL   OUTCRLF   ;start new line.
E5B9   3A 0C E7     NEWLN1:   LD   A,(CURPOS)   ;move the cursor to the starting position.
E5BC   21 0B E7               LD   HL,STARTING   
E5BF   BE                     CP   (HL)   
E5C0   D0                     RET   NC   ;there yet?
E5C1   0E 20                  LD   C,' '   
E5C3   CD 48 E5               CALL   OUTCHAR   ;nope, keep going.
E5C6   C3 B9 E5               JP   NEWLN1   
E5C9                          ; 
E5C9                          ;   Output a (cr) (lf) to the console device (screen).
E5C9                          ; 
E5C9   0E 0D        OUTCRLF:   LD   C,CR   
E5CB   CD 48 E5               CALL   OUTCHAR   
E5CE   0E 0A                  LD   C,LF   
E5D0   C3 48 E5               JP   OUTCHAR   
E5D3                          ; 
E5D3                          ;   Print message pointed to by (BC). It will end with a '$'.
E5D3                          ; 
E5D3   0A           PRTMESG:   LD   A,(BC)   ;check for terminating character.
E5D4   FE 24                  CP   '$'   
E5D6   C8                     RET   Z   
E5D7   03                     INC   BC   
E5D8   C5                     PUSH   BC   ;otherwise, bump pointer and print it.
E5D9   4F                     LD   C,A   
E5DA   CD 90 E5               CALL   OUTCON   
E5DD   C1                     POP   BC   
E5DE   C3 D3 E5               JP   PRTMESG   
E5E1                          ; 
E5E1                          ;   Function to execute a buffered read.
E5E1                          ; 
E5E1   3A 0C E7     RDBUFF:   LD   A,(CURPOS)   ;use present location as starting one.
E5E4   32 0B E7               LD   (STARTING),A   
E5E7   2A 43 E7               LD   HL,(PARAMS)   ;get the maximum buffer space.
E5EA   4E                     LD   C,(HL)   
E5EB   23                     INC   HL   ;point to first available space.
E5EC   E5                     PUSH   HL   ;and save.
E5ED   06 00                  LD   B,0   ;keep a character count.
E5EF   C5           RDBUF1:   PUSH   BC   
E5F0   E5                     PUSH   HL   
E5F1   CD FB E4     RDBUF2:   CALL   GETCHAR   ;get the next input character.
E5F4   E6 7F                  AND   7FH   ;strip bit 7.
E5F6   E1                     POP   HL   ;reset registers.
E5F7   C1                     POP   BC   
E5F8   FE 0D                  CP   CR   ;en of the line?
E5FA   CA C1 E6               JP   Z,RDBUF17   
E5FD   FE 0A                  CP   LF   
E5FF   CA C1 E6               JP   Z,RDBUF17   
E602   FE 08                  CP   BS   ;how about a backspace?
E604   C2 16 E6               JP   NZ,RDBUF3   
E607   78                     LD   A,B   ;yes, but ignore at the beginning of the line.
E608   B7                     OR   A   
E609   CA EF E5               JP   Z,RDBUF1   
E60C   05                     DEC   B   ;ok, update counter.
E60D   3A 0C E7               LD   A,(CURPOS)   ;if we backspace to the start of the line,
E610   32 0A E7               LD   (OUTFLAG),A   ;treat as a cancel (control-x).
E613   C3 70 E6               JP   RDBUF10   
E616   FE 7F        RDBUF3:   CP   DEL   ;user typed a rubout?
E618   C2 26 E6               JP   NZ,RDBUF4   
E61B   78                     LD   A,B   ;ignore at the start of the line.
E61C   B7                     OR   A   
E61D   CA EF E5               JP   Z,RDBUF1   
E620   7E                     LD   A,(HL)   ;ok, echo the prevoius character.
E621   05                     DEC   B   ;and reset pointers (counters).
E622   2B                     DEC   HL   
E623   C3 A9 E6               JP   RDBUF15   
E626   FE 05        RDBUF4:   CP   CNTRLE   ;physical end of line?
E628   C2 37 E6               JP   NZ,RDBUF5   
E62B   C5                     PUSH   BC   ;yes, do it.
E62C   E5                     PUSH   HL   
E62D   CD C9 E5               CALL   OUTCRLF   
E630   AF                     XOR   A   ;and update starting position.
E631   32 0B E7               LD   (STARTING),A   
E634   C3 F1 E5               JP   RDBUF2   
E637   FE 10        RDBUF5:   CP   CNTRLP   ;control-p?
E639   C2 48 E6               JP   NZ,RDBUF6   
E63C   E5                     PUSH   HL   ;yes, flip the print flag filp-flop byte.
E63D   21 0D E7               LD   HL,PRTFLAG   
E640   3E 01                  LD   A,1   ;PRTFLAG=1-PRTFLAG
E642   96                     SUB   (HL)   
E643   77                     LD   (HL),A   
E644   E1                     POP   HL   
E645   C3 EF E5               JP   RDBUF1   
E648   FE 18        RDBUF6:   CP   CNTRLX   ;control-x (cancel)?
E64A   C2 5F E6               JP   NZ,RDBUF8   
E64D   E1                     POP   HL   
E64E   3A 0B E7     RDBUF7:   LD   A,(STARTING)   ;yes, backup the cursor to here.
E651   21 0C E7               LD   HL,CURPOS   
E654   BE                     CP   (HL)   
E655   D2 E1 E5               JP   NC,RDBUFF   ;done yet?
E658   35                     DEC   (HL)   ;no, decrement pointer and output back up one space.
E659   CD A4 E5               CALL   BACKUP   
E65C   C3 4E E6               JP   RDBUF7   
E65F   FE 15        RDBUF8:   CP   CNTRLU   ;cntrol-u (cancel line)?
E661   C2 6B E6               JP   NZ,RDBUF9   
E664   CD B1 E5               CALL   NEWLINE   ;start a new line.
E667   E1                     POP   HL   
E668   C3 E1 E5               JP   RDBUFF   
E66B   FE 12        RDBUF9:   CP   CNTRLR   ;control-r?
E66D   C2 A6 E6               JP   NZ,RDBUF14   
E670   C5           RDBUF10:   PUSH   BC   ;yes, start a new line and retype the old one.
E671   CD B1 E5               CALL   NEWLINE   
E674   C1                     POP   BC   
E675   E1                     POP   HL   
E676   E5                     PUSH   HL   
E677   C5                     PUSH   BC   
E678   78           RDBUF11:   LD   A,B   ;done whole line yet?
E679   B7                     OR   A   
E67A   CA 8A E6               JP   Z,RDBUF12   
E67D   23                     INC   HL   ;nope, get next character.
E67E   4E                     LD   C,(HL)   
E67F   05                     DEC   B   ;count it.
E680   C5                     PUSH   BC   
E681   E5                     PUSH   HL   
E682   CD 7F E5               CALL   SHOWIT   ;and display it.
E685   E1                     POP   HL   
E686   C1                     POP   BC   
E687   C3 78 E6               JP   RDBUF11   
E68A   E5           RDBUF12:   PUSH   HL   ;done with line. If we were displaying
E68B   3A 0A E7               LD   A,(OUTFLAG)   ;then update cursor position.
E68E   B7                     OR   A   
E68F   CA F1 E5               JP   Z,RDBUF2   
E692   21 0C E7               LD   HL,CURPOS   ;because this line is shorter, we must
E695   96                     SUB   (HL)   ;back up the cursor (not the screen however)
E696   32 0A E7               LD   (OUTFLAG),A   ;some number of positions.
E699   CD A4 E5     RDBUF13:   CALL   BACKUP   ;note that as long as (OUTFLAG) is non
E69C   21 0A E7               LD   HL,OUTFLAG   ;zero, the screen will not be changed.
E69F   35                     DEC   (HL)   
E6A0   C2 99 E6               JP   NZ,RDBUF13   
E6A3   C3 F1 E5               JP   RDBUF2   ;now just get the next character.
E6A6                          ; 
E6A6                          ;   Just a normal character, put this in our buffer and echo.
E6A6                          ; 
E6A6   23           RDBUF14:   INC   HL   
E6A7   77                     LD   (HL),A   ;store character.
E6A8   04                     INC   B   ;and count it.
E6A9   C5           RDBUF15:   PUSH   BC   
E6AA   E5                     PUSH   HL   
E6AB   4F                     LD   C,A   ;echo it now.
E6AC   CD 7F E5               CALL   SHOWIT   
E6AF   E1                     POP   HL   
E6B0   C1                     POP   BC   
E6B1   7E                     LD   A,(HL)   ;was it an abort request?
E6B2   FE 03                  CP   CNTRLC   ;control-c abort?
E6B4   78                     LD   A,B   
E6B5   C2 BD E6               JP   NZ,RDBUF16   
E6B8   FE 01                  CP   1   ;only if at start of line.
E6BA   CA 00 00               JP   Z,0   
E6BD   B9           RDBUF16:   CP   C   ;nope, have we filled the buffer?
E6BE   DA EF E5               JP   C,RDBUF1   
E6C1   E1           RDBUF17:   POP   HL   ;yes end the line and return.
E6C2   70                     LD   (HL),B   
E6C3   0E 0D                  LD   C,CR   
E6C5   C3 48 E5               JP   OUTCHAR   ;output (cr) and return.
E6C8                          ; 
E6C8                          ;   Function to get a character from the console device.
E6C8                          ; 
E6C8   CD 06 E5     GETCON:   CALL   GETECHO   ;get and echo.
E6CB   C3 01 E7               JP   SETSTAT   ;save status and return.
E6CE                          ; 
E6CE                          ;   Function to get a character from the tape reader device.
E6CE                          ; 
E6CE   CD 15 F2     GETRDR:   CALL   READER   ;get a character from reader, set status and return.
E6D1   C3 01 E7               JP   SETSTAT   
E6D4                          ; 
E6D4                          ;  Function to perform direct console i/o. If (C) contains (FF)
E6D4                          ; then this is an input request. If (C) contains (FE) then
E6D4                          ; this is a status request. Otherwise we are to output (C).
E6D4                          ; 
E6D4   79           DIRCIO:   LD   A,C   ;test for (FF).
E6D5   3C                     INC   A   
E6D6   CA E0 E6               JP   Z,DIRC1   
E6D9   3C                     INC   A   ;test for (FE).
E6DA   CA 06 F2               JP   Z,CONST   
E6DD   C3 0C F2               JP   CONOUT   ;just output (C).
E6E0   CD 06 F2     DIRC1:    CALL   CONST   ;this is an input request.
E6E3   B7                     OR   A   
E6E4   CA 93 F1               JP   Z,GOBACK1   ;not ready? Just return (directly).
E6E7   CD 09 F2               CALL   CONIN   ;yes, get character.
E6EA   C3 01 E7               JP   SETSTAT   ;set status and return.
E6ED                          ; 
E6ED                          ;   Function to return the i/o byte.
E6ED                          ; 
E6ED   3A 03 00     GETIOB:   LD   A,(IOBYTE)   
E6F0   C3 01 E7               JP   SETSTAT   
E6F3                          ; 
E6F3                          ;   Function to set the i/o byte.
E6F3                          ; 
E6F3   21 03 00     SETIOB:   LD   HL,IOBYTE   
E6F6   71                     LD   (HL),C   
E6F7   C9                     RET   
E6F8                          ; 
E6F8                          ;   Function to print the character string pointed to by (DE)
E6F8                          ; on the console device. The string ends with a '$'.
E6F8                          ; 
E6F8   EB           PRTSTR:   EX   DE,HL   
E6F9   4D                     LD   C,L   
E6FA   44                     LD   B,H   ;now (BC) points to it.
E6FB   C3 D3 E5               JP   PRTMESG   
E6FE                          ; 
E6FE                          ;   Function to interigate the console device.
E6FE                          ; 
E6FE   CD 23 E5     GETCSTS:   CALL   CKCONSOL   
E701                          ; 
E701                          ;   Get here to set the status and return to the cleanup
E701                          ; section. Then back to the user.
E701                          ; 
E701   32 45 E7     SETSTAT:   LD   (STATUS),A   
E704   C9           RTN:      RET   
E705                          ; 
E705                          ;   Set the status to 1 (read or write error code).
E705                          ; 
E705   3E 01        IOERR1:   LD   A,1   
E707   C3 01 E7               JP   SETSTAT   
E70A                          ; 
E70A   00           OUTFLAG:   DB   0   ;output flag (non zero means no output).
E70B   02           STARTING:   DB   2   ;starting position for cursor.
E70C   00           CURPOS:   DB   0   ;cursor position (0=start of line).
E70D   00           PRTFLAG:   DB   0   ;printer flag (control-p toggle). List if non zero.
E70E   00           CHARBUF:   DB   0   ;single input character buffer.
E70F                          ; 
E70F                          ;   Stack area for BDOS calls.
E70F                          ; 
E70F   00 00        USRSTACK:   DW   0   ;save users stack pointer here.
E711                          ; 
E711   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
E729   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
E741                STKAREA:   EQU   $   
E741                          ; 
E741   00           USERNO:   DB   0   ;current user number.
E742   00           ACTIVE:   DB   0   ;currently active drive.
E743   00 00        PARAMS:   DW   0   ;save (DE) parameters here on entry.
E745   00 00        STATUS:   DW   0   ;status returned from bdos function.
E747                          ; 
E747                          ;   Select error occured, jump to error routine.
E747                          ; 
E747   21 0B E4     SLCTERR:   LD   HL,BADSLCT   
E74A                          ; 
E74A                          ;   Jump to (HL) indirectly.
E74A                          ; 
E74A   5E           JUMPHL:   LD   E,(HL)   
E74B   23                     INC   HL   
E74C   56                     LD   D,(HL)   ;now (DE) contain the desired address.
E74D   EB                     EX   DE,HL   
E74E   E9                     JP   (HL)   
E74F                          ; 
E74F                          ;   Block move. (DE) to (HL), (C) bytes total.
E74F                          ; 
E74F   0C           DE2HL:    INC   C   ;is count down to zero?
E750   0D           DE2HL1:   DEC   C   
E751   C8                     RET   Z   ;yes, we are done.
E752   1A                     LD   A,(DE)   ;no, move one more byte.
E753   77                     LD   (HL),A   
E754   13                     INC   DE   
E755   23                     INC   HL   
E756   C3 50 E7               JP   DE2HL1   ;and repeat.
E759                          ; 
E759                          ;   Select the desired drive.
E759                          ; 
E759   3A 42 E7     SELECT:   LD   A,(ACTIVE)   ;get active disk.
E75C   E6 03                  AND   3   
E75E   4F                     LD   C,A   
E75F   CD 1B F2               CALL   SELDSK   ;select it.
E762   7C                     LD   A,H   ;valid drive?
E763   B5                     OR   L   ;valid drive?
E764   C8                     RET   Z   ;return if not.
E765                          ; 
E765                          ;   Here, the BIOS returned the address of the parameter block
E765                          ; in (HL). We will extract the necessary pointers and save them.
E765                          ; 
E765   5E                     LD   E,(HL)   ;yes, get address of translation table into (DE).
E766   23                     INC   HL   
E767   56                     LD   D,(HL)   
E768   23                     INC   HL   
E769   22 B5 F1               LD   (SCRATCH1),HL   ;save pointers to scratch areas.
E76C   23                     INC   HL   
E76D   23                     INC   HL   
E76E   22 B7 F1               LD   (SCRATCH2),HL   ;ditto.
E771   23                     INC   HL   
E772   23                     INC   HL   
E773   22 B9 F1               LD   (SCRATCH3),HL   ;ditto.
E776   23                     INC   HL   
E777   23                     INC   HL   
E778   EB                     EX   DE,HL   ;now save the translation table address.
E779   22 D2 F1               LD   (XLATE),HL   
E77C   21 BB F1               LD   HL,DIRBUF   ;put the next 8 bytes here.
E77F   0E 08                  LD   C,8   ;they consist of the directory buffer
E781   CD 4F E7               CALL   DE2HL   ;pointer, parameter block pointer,
E784   2A BD F1               LD   HL,(DISKPB)   ;check and allocation vectors.
E787   EB                     EX   DE,HL   
E788   21 C3 F1               LD   HL,SECTORS   ;move parameter block into our ram.
E78B   0E 0F                  LD   C,15   ;it is 15 bytes long.
E78D   CD 4F E7               CALL   DE2HL   
E790   2A C8 F1               LD   HL,(DSKSIZE)   ;check disk size.
E793   7C                     LD   A,H   ;more than 256 blocks on this?
E794   21 DF F1               LD   HL,BIGDISK   
E797   36 FF                  LD   (HL),0FFH   ;set to samll.
E799   B7                     OR   A   
E79A   CA 9F E7               JP   Z,SELECT1   
E79D   36 00                  LD   (HL),0   ;wrong, set to large.
E79F   3E FF        SELECT1:   LD   A,0FFH   ;clear the zero flag.
E7A1   B7                     OR   A   
E7A2   C9                     RET   
E7A3                          ; 
E7A3                          ;   Routine to home the disk track head and clear pointers.
E7A3                          ; 
E7A3   CD 18 F2     HOMEDRV:   CALL   HOME   ;home the head.
E7A6   AF                     XOR   A   
E7A7   2A B7 F1               LD   HL,(SCRATCH2)   ;set our track pointer also.
E7AA   77                     LD   (HL),A   
E7AB   23                     INC   HL   
E7AC   77                     LD   (HL),A   
E7AD   2A B9 F1               LD   HL,(SCRATCH3)   ;and our sector pointer.
E7B0   77                     LD   (HL),A   
E7B1   23                     INC   HL   
E7B2   77                     LD   (HL),A   
E7B3   C9                     RET   
E7B4                          ; 
E7B4                          ;   Do the actual disk read and check the error return status.
E7B4                          ; 
E7B4   CD 27 F2     DOREAD:   CALL   READ   
E7B7   C3 BD E7               JP   IORET   
E7BA                          ; 
E7BA                          ;   Do the actual disk write and handle any bios error.
E7BA                          ; 
E7BA   CD 2A F2     DOWRITE:   CALL   WRITE   
E7BD   B7           IORET:    OR   A   
E7BE   C8                     RET   Z   ;return unless an error occured.
E7BF   21 09 E4               LD   HL,BADSCTR   ;bad read/write on this sector.
E7C2   C3 4A E7               JP   JUMPHL   
E7C5                          ; 
E7C5                          ;   Routine to select the track and sector that the desired
E7C5                          ; block number falls in.
E7C5                          ; 
E7C5   2A EC F1     TRKSEC:   LD   HL,(FILEPOS)   ;get position of last accessed file
E7C8   0E 02                  LD   C,2   ;in directory and compute sector #.
E7CA   CD EC E8               CALL   SHIFTR   ;sector #=file-position/4.
E7CD   22 E7 F1               LD   (BLKNMBR),HL   ;save this as the block number of interest.
E7D0   22 EE F1               LD   (CKSUMTBL),HL   ;what's it doing here too?
E7D3                          ; 
E7D3                          ;   if the sector number has already been set (BLKNMBR), enter
E7D3                          ; at this point.
E7D3                          ; 
E7D3   21 E7 F1     TRKSEC1:   LD   HL,BLKNMBR   
E7D6   4E                     LD   C,(HL)   ;move sector number into (BC).
E7D7   23                     INC   HL   
E7D8   46                     LD   B,(HL)   
E7D9   2A B9 F1               LD   HL,(SCRATCH3)   ;get current sector number and
E7DC   5E                     LD   E,(HL)   ;move this into (DE).
E7DD   23                     INC   HL   
E7DE   56                     LD   D,(HL)   
E7DF   2A B7 F1               LD   HL,(SCRATCH2)   ;get current track number.
E7E2   7E                     LD   A,(HL)   ;and this into (HL).
E7E3   23                     INC   HL   
E7E4   66                     LD   H,(HL)   
E7E5   6F                     LD   L,A   
E7E6   79           TRKSEC2:   LD   A,C   ;is desired sector before current one?
E7E7   93                     SUB   E   
E7E8   78                     LD   A,B   
E7E9   9A                     SBC   A,D   
E7EA   D2 FC E7               JP   NC,TRKSEC3   
E7ED   E5                     PUSH   HL   ;yes, decrement sectors by one track.
E7EE   2A C3 F1               LD   HL,(SECTORS)   ;get sectors per track.
E7F1   7B                     LD   A,E   
E7F2   95                     SUB   L   
E7F3   5F                     LD   E,A   
E7F4   7A                     LD   A,D   
E7F5   9C                     SBC   A,H   
E7F6   57                     LD   D,A   ;now we have backed up one full track.
E7F7   E1                     POP   HL   
E7F8   2B                     DEC   HL   ;adjust track counter.
E7F9   C3 E6 E7               JP   TRKSEC2   
E7FC   E5           TRKSEC3:   PUSH   HL   ;desired sector is after current one.
E7FD   2A C3 F1               LD   HL,(SECTORS)   ;get sectors per track.
E800   19                     ADD   HL,DE   ;bump sector pointer to next track.
E801   DA 11 E8               JP   C,TRKSEC4   
E804   79                     LD   A,C   ;is desired sector now before current one?
E805   95                     SUB   L   
E806   78                     LD   A,B   
E807   9C                     SBC   A,H   
E808   DA 11 E8               JP   C,TRKSEC4   
E80B   EB                     EX   DE,HL   ;not yes, increment track counter
E80C   E1                     POP   HL   ;and continue until it is.
E80D   23                     INC   HL   
E80E   C3 FC E7               JP   TRKSEC3   
E811                          ; 
E811                          ;   here we have determined the track number that contains the
E811                          ; desired sector.
E811                          ; 
E811   E1           TRKSEC4:   POP   HL   ;get track number (HL).
E812   C5                     PUSH   BC   
E813   D5                     PUSH   DE   
E814   E5                     PUSH   HL   
E815   EB                     EX   DE,HL   
E816   2A D0 F1               LD   HL,(OFFSET)   ;adjust for first track offset.
E819   19                     ADD   HL,DE   
E81A   44                     LD   B,H   
E81B   4D                     LD   C,L   
E81C   CD 1E F2               CALL   SETTRK   ;select this track.
E81F   D1                     POP   DE   ;reset current track pointer.
E820   2A B7 F1               LD   HL,(SCRATCH2)   
E823   73                     LD   (HL),E   
E824   23                     INC   HL   
E825   72                     LD   (HL),D   
E826   D1                     POP   DE   
E827   2A B9 F1               LD   HL,(SCRATCH3)   ;reset the first sector on this track.
E82A   73                     LD   (HL),E   
E82B   23                     INC   HL   
E82C   72                     LD   (HL),D   
E82D   C1                     POP   BC   
E82E   79                     LD   A,C   ;now subtract the desired one.
E82F   93                     SUB   E   ;to make it relative (1-# sectors/track).
E830   4F                     LD   C,A   
E831   78                     LD   A,B   
E832   9A                     SBC   A,D   
E833   47                     LD   B,A   
E834   2A D2 F1               LD   HL,(XLATE)   ;translate this sector according to this table.
E837   EB                     EX   DE,HL   
E838   CD 30 F2               CALL   SECTRN   ;let the bios translate it.
E83B   4D                     LD   C,L   
E83C   44                     LD   B,H   
E83D   C3 21 F2               JP   SETSEC   ;and select it.
E840                          ; 
E840                          ;   Compute block number from record number (SAVNREC) and
E840                          ; extent number (SAVEXT).
E840                          ; 
E840   21 C5 F1     GETBLOCK:   LD   HL,BLKSHFT   ;get logical to physical conversion.
E843   4E                     LD   C,(HL)   ;note that this is base 2 log of ratio.
E844   3A E5 F1               LD   A,(SAVNREC)   ;get record number.
E847   B7           GETBLK1:   OR   A   ;compute (A)=(A)/2^BLKSHFT.
E848   1F                     RRA   
E849   0D                     DEC   C   
E84A   C2 47 E8               JP   NZ,GETBLK1   
E84D   47                     LD   B,A   ;save result in (B).
E84E   3E 08                  LD   A,8   
E850   96                     SUB   (HL)   
E851   4F                     LD   C,A   ;compute (C)=8-BLKSHFT.
E852   3A E4 F1               LD   A,(SAVEXT)   
E855   0D           GETBLK2:   DEC   C   ;compute (A)=SAVEXT*2^(8-BLKSHFT).
E856   CA 5E E8               JP   Z,GETBLK3   
E859   B7                     OR   A   
E85A   17                     RLA   
E85B   C3 55 E8               JP   GETBLK2   
E85E   80           GETBLK3:   ADD   A,B   
E85F   C9                     RET   
E860                          ; 
E860                          ;   Routine to extract the (BC) block byte from the fcb pointed
E860                          ; to by (PARAMS). If this is a big-disk, then these are 16 bit
E860                          ; block numbers, else they are 8 bit numbers.
E860                          ; Number is returned in (HL).
E860                          ; 
E860   2A 43 E7     EXTBLK:   LD   HL,(PARAMS)   ;get fcb address.
E863   11 10 00               LD   DE,16   ;block numbers start 16 bytes into fcb.
E866   19                     ADD   HL,DE   
E867   09                     ADD   HL,BC   
E868   3A DF F1               LD   A,(BIGDISK)   ;are we using a big-disk?
E86B   B7                     OR   A   
E86C   CA 73 E8               JP   Z,EXTBLK1   
E86F   6E                     LD   L,(HL)   ;no, extract an 8 bit number from the fcb.
E870   26 00                  LD   H,0   
E872   C9                     RET   
E873   09           EXTBLK1:   ADD   HL,BC   ;yes, extract a 16 bit number.
E874   5E                     LD   E,(HL)   
E875   23                     INC   HL   
E876   56                     LD   D,(HL)   
E877   EB                     EX   DE,HL   ;return in (HL).
E878   C9                     RET   
E879                          ; 
E879                          ;   Compute block number.
E879                          ; 
E879   CD 40 E8     COMBLK:   CALL   GETBLOCK   
E87C   4F                     LD   C,A   
E87D   06 00                  LD   B,0   
E87F   CD 60 E8               CALL   EXTBLK   
E882   22 E7 F1               LD   (BLKNMBR),HL   
E885   C9                     RET   
E886                          ; 
E886                          ;   Check for a zero block number (unused).
E886                          ; 
E886   2A E7 F1     CHKBLK:   LD   HL,(BLKNMBR)   
E889   7D                     LD   A,L   ;is it zero?
E88A   B4                     OR   H   
E88B   C9                     RET   
E88C                          ; 
E88C                          ;   Adjust physical block (BLKNMBR) and convert to logical
E88C                          ; sector (LOGSECT). This is the starting sector of this block.
E88C                          ; The actual sector of interest is then added to this and the
E88C                          ; resulting sector number is stored back in (BLKNMBR). This
E88C                          ; will still have to be adjusted for the track number.
E88C                          ; 
E88C   3A C5 F1     LOGICAL:   LD   A,(BLKSHFT)   ;get log2(physical/logical sectors).
E88F   2A E7 F1               LD   HL,(BLKNMBR)   ;get physical sector desired.
E892   29           LOGICL1:   ADD   HL,HL   ;compute logical sector number.
E893   3D                     DEC   A   ;note logical sectors are 128 bytes long.
E894   C2 92 E8               JP   NZ,LOGICL1   
E897   22 E9 F1               LD   (LOGSECT),HL   ;save logical sector.
E89A   3A C6 F1               LD   A,(BLKMASK)   ;get block mask.
E89D   4F                     LD   C,A   
E89E   3A E5 F1               LD   A,(SAVNREC)   ;get next sector to access.
E8A1   A1                     AND   C   ;extract the relative position within physical block.
E8A2   B5                     OR   L   ;and add it too logical sector.
E8A3   6F                     LD   L,A   
E8A4   22 E7 F1               LD   (BLKNMBR),HL   ;and store.
E8A7   C9                     RET   
E8A8                          ; 
E8A8                          ;   Set (HL) to point to extent byte in fcb.
E8A8                          ; 
E8A8   2A 43 E7     SETEXT:   LD   HL,(PARAMS)   
E8AB   11 0C 00               LD   DE,12   ;it is the twelth byte.
E8AE   19                     ADD   HL,DE   
E8AF   C9                     RET   
E8B0                          ; 
E8B0                          ;   Set (HL) to point to record count byte in fcb and (DE) to
E8B0                          ; next record number byte.
E8B0                          ; 
E8B0   2A 43 E7     SETHLDE:   LD   HL,(PARAMS)   
E8B3   11 0F 00               LD   DE,15   ;record count byte (#15).
E8B6   19                     ADD   HL,DE   
E8B7   EB                     EX   DE,HL   
E8B8   21 11 00               LD   HL,17   ;next record number (#32).
E8BB   19                     ADD   HL,DE   
E8BC   C9                     RET   
E8BD                          ; 
E8BD                          ;   Save current file data from fcb.
E8BD                          ; 
E8BD   CD B0 E8     STRDATA:   CALL   SETHLDE   
E8C0   7E                     LD   A,(HL)   ;get and store record count byte.
E8C1   32 E5 F1               LD   (SAVNREC),A   
E8C4   EB                     EX   DE,HL   
E8C5   7E                     LD   A,(HL)   ;get and store next record number byte.
E8C6   32 E3 F1               LD   (SAVNXT),A   
E8C9   CD A8 E8               CALL   SETEXT   ;point to extent byte.
E8CC   3A C7 F1               LD   A,(EXTMASK)   ;get extent mask.
E8CF   A6                     AND   (HL)   
E8D0   32 E4 F1               LD   (SAVEXT),A   ;and save extent here.
E8D3   C9                     RET   
E8D4                          ; 
E8D4                          ;   Set the next record to access. If (MODE) is set to 2, then
E8D4                          ; the last record byte (SAVNREC) has the correct number to access.
E8D4                          ; For sequential access, (MODE) will be equal to 1.
E8D4                          ; 
E8D4   CD B0 E8     SETNREC:   CALL   SETHLDE   
E8D7   3A D7 F1               LD   A,(MODE)   ;get sequential flag (=1).
E8DA   FE 02                  CP   2   ;a 2 indicates that no adder is needed.
E8DC   C2 E0 E8               JP   NZ,STNREC1   
E8DF   AF                     XOR   A   ;clear adder (random access?).
E8E0   4F           STNREC1:   LD   C,A   
E8E1   3A E5 F1               LD   A,(SAVNREC)   ;get last record number.
E8E4   81                     ADD   A,C   ;increment record count.
E8E5   77                     LD   (HL),A   ;and set fcb's next record byte.
E8E6   EB                     EX   DE,HL   
E8E7   3A E3 F1               LD   A,(SAVNXT)   ;get next record byte from storage.
E8EA   77                     LD   (HL),A   ;and put this into fcb as number of records used.
E8EB   C9                     RET   
E8EC                          ; 
E8EC                          ;   Shift (HL) right (C) bits.
E8EC                          ; 
E8EC   0C           SHIFTR:   INC   C   
E8ED   0D           SHIFTR1:   DEC   C   
E8EE   C8                     RET   Z   
E8EF   7C                     LD   A,H   
E8F0   B7                     OR   A   
E8F1   1F                     RRA   
E8F2   67                     LD   H,A   
E8F3   7D                     LD   A,L   
E8F4   1F                     RRA   
E8F5   6F                     LD   L,A   
E8F6   C3 ED E8               JP   SHIFTR1   
E8F9                          ; 
E8F9                          ;   Compute the check-sum for the directory buffer. Return
E8F9                          ; integer sum in (A).
E8F9                          ; 
E8F9   0E 80        CHECKSUM:   LD   C,128   ;length of buffer.
E8FB   2A BB F1               LD   HL,(DIRBUF)   ;get its location.
E8FE   AF                     XOR   A   ;clear summation byte.
E8FF   86           CHKSUM1:   ADD   A,(HL)   ;and compute sum ignoring carries.
E900   23                     INC   HL   
E901   0D                     DEC   C   
E902   C2 FF E8               JP   NZ,CHKSUM1   
E905   C9                     RET   
E906                          ; 
E906                          ;   Shift (HL) left (C) bits.
E906                          ; 
E906   0C           SHIFTL:   INC   C   
E907   0D           SHIFTL1:   DEC   C   
E908   C8                     RET   Z   
E909   29                     ADD   HL,HL   ;shift left 1 bit.
E90A   C3 07 E9               JP   SHIFTL1   
E90D                          ; 
E90D                          ;   Routine to set a bit in a 16 bit value contained in (BC).
E90D                          ; The bit set depends on the current drive selection.
E90D                          ; 
E90D   C5           SETBIT:   PUSH   BC   ;save 16 bit word.
E90E   3A 42 E7               LD   A,(ACTIVE)   ;get active drive.
E911   4F                     LD   C,A   
E912   21 01 00               LD   HL,1   
E915   CD 06 E9               CALL   SHIFTL   ;shift bit 0 into place.
E918   C1                     POP   BC   ;now 'or' this with the original word.
E919   79                     LD   A,C   
E91A   B5                     OR   L   
E91B   6F                     LD   L,A   ;low byte done, do high byte.
E91C   78                     LD   A,B   
E91D   B4                     OR   H   
E91E   67                     LD   H,A   
E91F   C9                     RET   
E920                          ; 
E920                          ;   Extract the write protect status bit for the current drive.
E920                          ; The result is returned in (A), bit 0.
E920                          ; 
E920   2A AF F1     GETWPRT:   LD   HL,(WRTPRT)   ;get status bytes.
E923   3A 42 E7               LD   A,(ACTIVE)   ;which drive is current?
E926   4F                     LD   C,A   
E927   CD EC E8               CALL   SHIFTR   ;shift status such that bit 0 is the
E92A   7D                     LD   A,L   ;one of interest for this drive.
E92B   E6 01                  AND   01H   ;and isolate it.
E92D   C9                     RET   
E92E                          ; 
E92E                          ;   Function to write protect the current disk.
E92E                          ; 
E92E   21 AF F1     WRTPRTD:   LD   HL,WRTPRT   ;point to status word.
E931   4E                     LD   C,(HL)   ;set (BC) equal to the status.
E932   23                     INC   HL   
E933   46                     LD   B,(HL)   
E934   CD 0D E9               CALL   SETBIT   ;and set this bit according to current drive.
E937   22 AF F1               LD   (WRTPRT),HL   ;then save.
E93A   2A CA F1               LD   HL,(DIRSIZE)   ;now save directory size limit.
E93D   23                     INC   HL   ;remember the last one.
E93E   EB                     EX   DE,HL   
E93F   2A B5 F1               LD   HL,(SCRATCH1)   ;and store it here.
E942   73                     LD   (HL),E   ;put low byte.
E943   23                     INC   HL   
E944   72                     LD   (HL),D   ;then high byte.
E945   C9                     RET   
E946                          ; 
E946                          ;   Check for a read only file.
E946                          ; 
E946   CD 60 E9     CHKROFL:   CALL   FCB2HL   ;set (HL) to file entry in directory buffer.
E949   11 09 00     CKROF1:   LD   DE,9   ;look at bit 7 of the ninth byte.
E94C   19                     ADD   HL,DE   
E94D   7E                     LD   A,(HL)   
E94E   17                     RLA   
E94F   D0                     RET   NC   ;return if ok.
E950   21 0F E4               LD   HL,ROFILE   ;else, print error message and terminate.
E953   C3 4A E7               JP   JUMPHL   
E956                          ; 
E956                          ;   Check the write protect status of the active disk.
E956                          ; 
E956   CD 20 E9     CHKWPRT:   CALL   GETWPRT   
E959   C8                     RET   Z   ;return if ok.
E95A   21 0D E4               LD   HL,RODISK   ;else print message and terminate.
E95D   C3 4A E7               JP   JUMPHL   
E960                          ; 
E960                          ;   Routine to set (HL) pointing to the proper entry in the
E960                          ; directory buffer.
E960                          ; 
E960   2A BB F1     FCB2HL:   LD   HL,(DIRBUF)   ;get address of buffer.
E963   3A EB F1               LD   A,(FCBPOS)   ;relative position of file.
E966                          ; 
E966                          ;   Routine to add (A) to (HL).
E966                          ; 
E966   85           ADDA2HL:   ADD   A,L   
E967   6F                     LD   L,A   
E968   D0                     RET   NC   
E969   24                     INC   H   ;take care of any carry.
E96A   C9                     RET   
E96B                          ; 
E96B                          ;   Routine to get the 's2' byte from the fcb supplied in
E96B                          ; the initial parameter specification.
E96B                          ; 
E96B   2A 43 E7     GETS2:    LD   HL,(PARAMS)   ;get address of fcb.
E96E   11 0E 00               LD   DE,14   ;relative position of 's2'.
E971   19                     ADD   HL,DE   
E972   7E                     LD   A,(HL)   ;extract this byte.
E973   C9                     RET   
E974                          ; 
E974                          ;   Clear the 's2' byte in the fcb.
E974                          ; 
E974   CD 6B E9     CLEARS2:   CALL   GETS2   ;this sets (HL) pointing to it.
E977   36 00                  LD   (HL),0   ;now clear it.
E979   C9                     RET   
E97A                          ; 
E97A                          ;   Set bit 7 in the 's2' byte of the fcb.
E97A                          ; 
E97A   CD 6B E9     SETS2B7:   CALL   GETS2   ;get the byte.
E97D   F6 80                  OR   80H   ;and set bit 7.
E97F   77                     LD   (HL),A   ;then store.
E980   C9                     RET   
E981                          ; 
E981                          ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
E981                          ; the difference. This checks to see if there are more file
E981                          ; names in the directory. We are at (FILEPOS) and there are
E981                          ; (SCRATCH1) of them to check.
E981                          ; 
E981   2A EC F1     MOREFLS:   LD   HL,(FILEPOS)   ;we are here.
E984   EB                     EX   DE,HL   
E985   2A B5 F1               LD   HL,(SCRATCH1)   ;and don't go past here.
E988   7B                     LD   A,E   ;compute difference but don't keep.
E989   96                     SUB   (HL)   
E98A   23                     INC   HL   
E98B   7A                     LD   A,D   
E98C   9E                     SBC   A,(HL)   ;set carry if no more names.
E98D   C9                     RET   
E98E                          ; 
E98E                          ;   Call this routine to prevent (SCRATCH1) from being greater
E98E                          ; than (FILEPOS).
E98E                          ; 
E98E   CD 81 E9     CHKNMBR:   CALL   MOREFLS   ;SCRATCH1 too big?
E991   D8                     RET   C   
E992   13                     INC   DE   ;yes, reset it to (FILEPOS).
E993   72                     LD   (HL),D   
E994   2B                     DEC   HL   
E995   73                     LD   (HL),E   
E996   C9                     RET   
E997                          ; 
E997                          ;   Compute (HL)=(DE)-(HL)
E997                          ; 
E997   7B           SUBHL:    LD   A,E   ;compute difference.
E998   95                     SUB   L   
E999   6F                     LD   L,A   ;store low byte.
E99A   7A                     LD   A,D   
E99B   9C                     SBC   A,H   
E99C   67                     LD   H,A   ;and then high byte.
E99D   C9                     RET   
E99E                          ; 
E99E                          ;   Set the directory checksum byte.
E99E                          ; 
E99E   0E FF        SETDIR:   LD   C,0FFH   
E9A0                          ; 
E9A0                          ;   Routine to set or compare the directory checksum byte. If
E9A0                          ; (C)=0ffh, then this will set the checksum byte. Else the byte
E9A0                          ; will be checked. If the check fails (the disk has been changed),
E9A0                          ; then this disk will be write protected.
E9A0                          ; 
E9A0   2A EE F1     CHECKDIR:   LD   HL,(CKSUMTBL)   
E9A3   EB                     EX   DE,HL   
E9A4   2A CE F1               LD   HL,(ALLOC1)   
E9A7   CD 97 E9               CALL   SUBHL   
E9AA   D0                     RET   NC   ;ok if (CKSUMTBL) > (ALLOC1), so return.
E9AB   C5                     PUSH   BC   
E9AC   CD F9 E8               CALL   CHECKSUM   ;else compute checksum.
E9AF   2A BF F1               LD   HL,(CHKVECT)   ;get address of checksum table.
E9B2   EB                     EX   DE,HL   
E9B3   2A EE F1               LD   HL,(CKSUMTBL)   
E9B6   19                     ADD   HL,DE   ;set (HL) to point to byte for this drive.
E9B7   C1                     POP   BC   
E9B8   0C                     INC   C   ;set or check ?
E9B9   CA C6 E9               JP   Z,CHKDIR1   
E9BC   BE                     CP   (HL)   ;check them.
E9BD   C8                     RET   Z   ;return if they are the same.
E9BE   CD 81 E9               CALL   MOREFLS   ;not the same, do we care?
E9C1   D0                     RET   NC   
E9C2   CD 2E E9               CALL   WRTPRTD   ;yes, mark this as write protected.
E9C5   C9                     RET   
E9C6   77           CHKDIR1:   LD   (HL),A   ;just set the byte.
E9C7   C9                     RET   
E9C8                          ; 
E9C8                          ;   Do a write to the directory of the current disk.
E9C8                          ; 
E9C8   CD 9E E9     DIRWRITE:   CALL   SETDIR   ;set checksum byte.
E9CB   CD E2 E9               CALL   DIRDMA   ;set directory dma address.
E9CE   0E 01                  LD   C,1   ;tell the bios to actually write.
E9D0   CD BA E7               CALL   DOWRITE   ;then do the write.
E9D3   C3 DC E9               JP   DEFDMA   
E9D6                          ; 
E9D6                          ;   Read from the directory.
E9D6                          ; 
E9D6   CD E2 E9     DIRREAD:   CALL   DIRDMA   ;set the directory dma address.
E9D9   CD B4 E7               CALL   DOREAD   ;and read it.
E9DC                          ; 
E9DC                          ;   Routine to set the dma address to the users choice.
E9DC                          ; 
E9DC   21 B3 F1     DEFDMA:   LD   HL,USERDMA   ;reset the default dma address and return.
E9DF   C3 E5 E9               JP   DIRDMA1   
E9E2                          ; 
E9E2                          ;   Routine to set the dma address for directory work.
E9E2                          ; 
E9E2   21 BB F1     DIRDMA:   LD   HL,DIRBUF   
E9E5                          ; 
E9E5                          ;   Set the dma address. On entry, (HL) points to
E9E5                          ; word containing the desired dma address.
E9E5                          ; 
E9E5   4E           DIRDMA1:   LD   C,(HL)   
E9E6   23                     INC   HL   
E9E7   46                     LD   B,(HL)   ;setup (BC) and go to the bios to set it.
E9E8   C3 24 F2               JP   SETDMA   
E9EB                          ; 
E9EB                          ;   Move the directory buffer into user's dma space.
E9EB                          ; 
E9EB   2A BB F1     MOVEDIR:   LD   HL,(DIRBUF)   ;buffer is located here, and
E9EE   EB                     EX   DE,HL   
E9EF   2A B3 F1               LD   HL,(USERDMA)   ; put it here.
E9F2   0E 80                  LD   C,128   ;this is its length.
E9F4   C3 4F E7               JP   DE2HL   ;move it now and return.
E9F7                          ; 
E9F7                          ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
E9F7                          ; 
E9F7   21 EC F1     CKFILPOS:   LD   HL,FILEPOS   
E9FA   7E                     LD   A,(HL)   
E9FB   23                     INC   HL   
E9FC   BE                     CP   (HL)   ;are both bytes the same?
E9FD   C0                     RET   NZ   
E9FE   3C                     INC   A   ;yes, but are they each 0ffh?
E9FF   C9                     RET   
EA00                          ; 
EA00                          ;   Set location (FILEPOS) to 0ffffh.
EA00                          ; 
EA00   21 FF FF     STFILPOS:   LD   HL,0FFFFH   
EA03   22 EC F1               LD   (FILEPOS),HL   
EA06   C9                     RET   
EA07                          ; 
EA07                          ;   Move on to the next file position within the current
EA07                          ; directory buffer. If no more exist, set pointer to 0ffffh
EA07                          ; and the calling routine will check for this. Enter with (C)
EA07                          ; equal to 0ffh to cause the checksum byte to be set, else we
EA07                          ; will check this disk and set write protect if checksums are
EA07                          ; not the same (applies only if another directory sector must
EA07                          ; be read).
EA07                          ; 
EA07   2A CA F1     NXENTRY:   LD   HL,(DIRSIZE)   ;get directory entry size limit.
EA0A   EB                     EX   DE,HL   
EA0B   2A EC F1               LD   HL,(FILEPOS)   ;get current count.
EA0E   23                     INC   HL   ;go on to the next one.
EA0F   22 EC F1               LD   (FILEPOS),HL   
EA12   CD 97 E9               CALL   SUBHL   ;(HL)=(DIRSIZE)-(FILEPOS)
EA15   D2 1B EA               JP   NC,NXENT1   ;is there more room left?
EA18   C3 00 EA               JP   STFILPOS   ;no. Set this flag and return.
EA1B   3A EC F1     NXENT1:   LD   A,(FILEPOS)   ;get file position within directory.
EA1E   E6 03                  AND   03H   ;only look within this sector (only 4 entries fit).
EA20   06 05                  LD   B,5   ;convert to relative position (32 bytes each).
EA22   87           NXENT2:   ADD   A,A   ;note that this is not efficient code.
EA23   05                     DEC   B   ;5 'ADD A's would be better.
EA24   C2 22 EA               JP   NZ,NXENT2   
EA27   32 EB F1               LD   (FCBPOS),A   ;save it as position of fcb.
EA2A   B7                     OR   A   
EA2B   C0                     RET   NZ   ;return if we are within buffer.
EA2C   C5                     PUSH   BC   
EA2D   CD C5 E7               CALL   TRKSEC   ;we need the next directory sector.
EA30   CD D6 E9               CALL   DIRREAD   
EA33   C1                     POP   BC   
EA34   C3 A0 E9               JP   CHECKDIR   
EA37                          ; 
EA37                          ;   Routine to to get a bit from the disk space allocation
EA37                          ; map. It is returned in (A), bit position 0. On entry to here,
EA37                          ; set (BC) to the block number on the disk to check.
EA37                          ; On return, (D) will contain the original bit position for
EA37                          ; this block number and (HL) will point to the address for it.
EA37                          ; 
EA37   79           CKBITMAP:   LD   A,C   ;determine bit number of interest.
EA38   E6 07                  AND   07H   ;compute (D)=(E)=(C and 7)+1.
EA3A   3C                     INC   A   
EA3B   5F                     LD   E,A   ;save particular bit number.
EA3C   57                     LD   D,A   
EA3D                          ; 
EA3D                          ;   compute (BC)=(BC)/8.
EA3D                          ; 
EA3D   79                     LD   A,C   
EA3E   0F                     RRCA   ;now shift right 3 bits.
EA3F   0F                     RRCA   
EA40   0F                     RRCA   
EA41   E6 1F                  AND   1FH   ;and clear bits 7,6,5.
EA43   4F                     LD   C,A   
EA44   78                     LD   A,B   
EA45   87                     ADD   A,A   ;now shift (B) into bits 7,6,5.
EA46   87                     ADD   A,A   
EA47   87                     ADD   A,A   
EA48   87                     ADD   A,A   
EA49   87                     ADD   A,A   
EA4A   B1                     OR   C   ;and add in (C).
EA4B   4F                     LD   C,A   ;ok, (C) ha been completed.
EA4C   78                     LD   A,B   ;is there a better way of doing this?
EA4D   0F                     RRCA   
EA4E   0F                     RRCA   
EA4F   0F                     RRCA   
EA50   E6 1F                  AND   1FH   
EA52   47                     LD   B,A   ;and now (B) is completed.
EA53                          ; 
EA53                          ;   use this as an offset into the disk space allocation
EA53                          ; table.
EA53                          ; 
EA53   2A C1 F1               LD   HL,(ALOCVECT)   
EA56   09                     ADD   HL,BC   
EA57   7E                     LD   A,(HL)   ;now get correct byte.
EA58   07           CKBMAP1:   RLCA   ;get correct bit into position 0.
EA59   1D                     DEC   E   
EA5A   C2 58 EA               JP   NZ,CKBMAP1   
EA5D   C9                     RET   
EA5E                          ; 
EA5E                          ;   Set or clear the bit map such that block number (BC) will be marked
EA5E                          ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
EA5E                          ; 1 then it will be set (don't use anyother values).
EA5E                          ; 
EA5E   D5           STBITMAP:   PUSH   DE   
EA5F   CD 37 EA               CALL   CKBITMAP   ;get the byte of interest.
EA62   E6 FE                  AND   0FEH   ;clear the affected bit.
EA64   C1                     POP   BC   
EA65   B1                     OR   C   ;and now set it acording to (C).
EA66                          ; 
EA66                          ;  entry to restore the original bit position and then store
EA66                          ; in table. (A) contains the value, (D) contains the bit
EA66                          ; position (1-8), and (HL) points to the address within the
EA66                          ; space allocation table for this byte.
EA66                          ; 
EA66   0F           STBMAP1:   RRCA   ;restore original bit position.
EA67   15                     DEC   D   
EA68   C2 66 EA               JP   NZ,STBMAP1   
EA6B   77                     LD   (HL),A   ;and stor byte in table.
EA6C   C9                     RET   
EA6D                          ; 
EA6D                          ;   Set/clear space used bits in allocation map for this file.
EA6D                          ; On entry, (C)=1 to set the map and (C)=0 to clear it.
EA6D                          ; 
EA6D   CD 60 E9     SETFILE:   CALL   FCB2HL   ;get address of fcb
EA70   11 10 00               LD   DE,16   
EA73   19                     ADD   HL,DE   ;get to block number bytes.
EA74   C5                     PUSH   BC   
EA75   0E 11                  LD   C,17   ;check all 17 bytes (max) of table.
EA77   D1           SETFL1:   POP   DE   
EA78   0D                     DEC   C   ;done all bytes yet?
EA79   C8                     RET   Z   
EA7A   D5                     PUSH   DE   
EA7B   3A DF F1               LD   A,(BIGDISK)   ;check disk size for 16 bit block numbers.
EA7E   B7                     OR   A   
EA7F   CA 8A EA               JP   Z,SETFL2   
EA82   C5                     PUSH   BC   ;only 8 bit numbers. set (BC) to this one.
EA83   E5                     PUSH   HL   
EA84   4E                     LD   C,(HL)   ;get low byte from table, always
EA85   06 00                  LD   B,0   ;set high byte to zero.
EA87   C3 90 EA               JP   SETFL3   
EA8A   0D           SETFL2:   DEC   C   ;for 16 bit block numbers, adjust counter.
EA8B   C5                     PUSH   BC   
EA8C   4E                     LD   C,(HL)   ;now get both the low and high bytes.
EA8D   23                     INC   HL   
EA8E   46                     LD   B,(HL)   
EA8F   E5                     PUSH   HL   
EA90   79           SETFL3:   LD   A,C   ;block used?
EA91   B0                     OR   B   
EA92   CA 9F EA               JP   Z,SETFL4   
EA95   2A C8 F1               LD   HL,(DSKSIZE)   ;is this block number within the
EA98   7D                     LD   A,L   ;space on the disk?
EA99   91                     SUB   C   
EA9A   7C                     LD   A,H   
EA9B   98                     SBC   A,B   
EA9C   D4 5E EA               CALL   NC,STBITMAP   ;yes, set the proper bit.
EA9F   E1           SETFL4:   POP   HL   ;point to next block number in fcb.
EAA0   23                     INC   HL   
EAA1   C1                     POP   BC   
EAA2   C3 77 EA               JP   SETFL1   
EAA5                          ; 
EAA5                          ;   Construct the space used allocation bit map for the active
EAA5                          ; drive. If a file name starts with '$' and it is under the
EAA5                          ; current user number, then (STATUS) is set to minus 1. Otherwise
EAA5                          ; it is not set at all.
EAA5                          ; 
EAA5   2A C8 F1     BITMAP:   LD   HL,(DSKSIZE)   ;compute size of allocation table.
EAA8   0E 03                  LD   C,3   
EAAA   CD EC E8               CALL   SHIFTR   ;(HL)=(HL)/8.
EAAD   23                     INC   HL   ;at lease 1 byte.
EAAE   44                     LD   B,H   
EAAF   4D                     LD   C,L   ;set (BC) to the allocation table length.
EAB0                          ; 
EAB0                          ;   Initialize the bitmap for this drive. Right now, the first
EAB0                          ; two bytes are specified by the disk parameter block. However
EAB0                          ; a patch could be entered here if it were necessary to setup
EAB0                          ; this table in a special mannor. For example, the bios could
EAB0                          ; determine locations of 'bad blocks' and set them as already
EAB0                          ; 'used' in the map.
EAB0                          ; 
EAB0   2A C1 F1               LD   HL,(ALOCVECT)   ;now zero out the table now.
EAB3   36 00        BITMAP1:   LD   (HL),0   
EAB5   23                     INC   HL   
EAB6   0B                     DEC   BC   
EAB7   78                     LD   A,B   
EAB8   B1                     OR   C   
EAB9   C2 B3 EA               JP   NZ,BITMAP1   
EABC   2A CC F1               LD   HL,(ALLOC0)   ;get initial space used by directory.
EABF   EB                     EX   DE,HL   
EAC0   2A C1 F1               LD   HL,(ALOCVECT)   ;and put this into map.
EAC3   73                     LD   (HL),E   
EAC4   23                     INC   HL   
EAC5   72                     LD   (HL),D   
EAC6                          ; 
EAC6                          ;   End of initialization portion.
EAC6                          ; 
EAC6   CD A3 E7               CALL   HOMEDRV   ;now home the drive.
EAC9   2A B5 F1               LD   HL,(SCRATCH1)   
EACC   36 03                  LD   (HL),3   ;force next directory request to read
EACE   23                     INC   HL   ;in a sector.
EACF   36 00                  LD   (HL),0   
EAD1   CD 00 EA               CALL   STFILPOS   ;clear initial file position also.
EAD4   0E FF        BITMAP2:   LD   C,0FFH   ;read next file name in directory
EAD6   CD 07 EA               CALL   NXENTRY   ;and set checksum byte.
EAD9   CD F7 E9               CALL   CKFILPOS   ;is there another file?
EADC   C8                     RET   Z   
EADD   CD 60 E9               CALL   FCB2HL   ;yes, get its address.
EAE0   3E E5                  LD   A,0E5H   
EAE2   BE                     CP   (HL)   ;empty file entry?
EAE3   CA D4 EA               JP   Z,BITMAP2   
EAE6   3A 41 E7               LD   A,(USERNO)   ;no, correct user number?
EAE9   BE                     CP   (HL)   
EAEA   C2 F8 EA               JP   NZ,BITMAP3   
EAED   23                     INC   HL   
EAEE   7E                     LD   A,(HL)   ;yes, does name start with a '$'?
EAEF   D6 24                  SUB   '$'   
EAF1   C2 F8 EA               JP   NZ,BITMAP3   
EAF4   3D                     DEC   A   ;yes, set atatus to minus one.
EAF5   32 45 E7               LD   (STATUS),A   
EAF8   0E 01        BITMAP3:   LD   C,1   ;now set this file's space as used in bit map.
EAFA   CD 6D EA               CALL   SETFILE   
EAFD   CD 8E E9               CALL   CHKNMBR   ;keep (SCRATCH1) in bounds.
EB00   C3 D4 EA               JP   BITMAP2   
EB03                          ; 
EB03                          ;   Set the status (STATUS) and return.
EB03                          ; 
EB03   3A D6 F1     STSTATUS:   LD   A,(FNDSTAT)   
EB06   C3 01 E7               JP   SETSTAT   
EB09                          ; 
EB09                          ;   Check extents in (A) and (C). Set the zero flag if they
EB09                          ; are the same. The number of 16k chunks of disk space that
EB09                          ; the directory extent covers is expressad is (EXTMASK+1).
EB09                          ; No registers are modified.
EB09                          ; 
EB09   C5           SAMEXT:   PUSH   BC   
EB0A   F5                     PUSH   AF   
EB0B   3A C7 F1               LD   A,(EXTMASK)   ;get extent mask and use it to
EB0E   2F                     CPL   ;to compare both extent numbers.
EB0F   47                     LD   B,A   ;save resulting mask here.
EB10   79                     LD   A,C   ;mask first extent and save in (C).
EB11   A0                     AND   B   
EB12   4F                     LD   C,A   
EB13   F1                     POP   AF   ;now mask second extent and compare
EB14   A0                     AND   B   ;with the first one.
EB15   91                     SUB   C   
EB16   E6 1F                  AND   1FH   ;(* only check buts 0-4 *)
EB18   C1                     POP   BC   ;the zero flag is set if they are the same.
EB19   C9                     RET   ;restore (BC) and return.
EB1A                          ; 
EB1A                          ;   Search for the first occurence of a file name. On entry,
EB1A                          ; register (C) should contain the number of bytes of the fcb
EB1A                          ; that must match.
EB1A                          ; 
EB1A   3E FF        FINDFST:   LD   A,0FFH   
EB1C   32 D6 F1               LD   (FNDSTAT),A   
EB1F   21 DA F1               LD   HL,COUNTER   ;save character count.
EB22   71                     LD   (HL),C   
EB23   2A 43 E7               LD   HL,(PARAMS)   ;get filename to match.
EB26   22 DB F1               LD   (SAVEFCB),HL   ;and save.
EB29   CD 00 EA               CALL   STFILPOS   ;clear initial file position (set to 0ffffh).
EB2C   CD A3 E7               CALL   HOMEDRV   ;home the drive.
EB2F                          ; 
EB2F                          ;   Entry to locate the next occurence of a filename within the
EB2F                          ; directory. The disk is not expected to have been changed. If
EB2F                          ; it was, then it will be write protected.
EB2F                          ; 
EB2F   0E 00        FINDNXT:   LD   C,0   ;write protect the disk if changed.
EB31   CD 07 EA               CALL   NXENTRY   ;get next filename entry in directory.
EB34   CD F7 E9               CALL   CKFILPOS   ;is file position = 0ffffh?
EB37   CA 96 EB               JP   Z,FNDNXT6   ;yes, exit now then.
EB3A   2A DB F1               LD   HL,(SAVEFCB)   ;set (DE) pointing to filename to match.
EB3D   EB                     EX   DE,HL   
EB3E   1A                     LD   A,(DE)   
EB3F   FE E5                  CP   0E5H   ;empty directory entry?
EB41   CA 4C EB               JP   Z,FNDNXT1   ;(* are we trying to reserect erased entries? *)
EB44   D5                     PUSH   DE   
EB45   CD 81 E9               CALL   MOREFLS   ;more files in directory?
EB48   D1                     POP   DE   
EB49   D2 96 EB               JP   NC,FNDNXT6   ;no more. Exit now.
EB4C   CD 60 E9     FNDNXT1:   CALL   FCB2HL   ;get address of this fcb in directory.
EB4F   3A DA F1               LD   A,(COUNTER)   ;get number of bytes (characters) to check.
EB52   4F                     LD   C,A   
EB53   06 00                  LD   B,0   ;initialize byte position counter.
EB55   79           FNDNXT2:   LD   A,C   ;are we done with the compare?
EB56   B7                     OR   A   
EB57   CA 85 EB               JP   Z,FNDNXT5   
EB5A   1A                     LD   A,(DE)   ;no, check next byte.
EB5B   FE 3F                  CP   '?'   ;don't care about this character?
EB5D   CA 7E EB               JP   Z,FNDNXT4   
EB60   78                     LD   A,B   ;get bytes position in fcb.
EB61   FE 0D                  CP   13   ;don't care about the thirteenth byte either.
EB63   CA 7E EB               JP   Z,FNDNXT4   
EB66   FE 0C                  CP   12   ;extent byte?
EB68   1A                     LD   A,(DE)   
EB69   CA 75 EB               JP   Z,FNDNXT3   
EB6C   96                     SUB   (HL)   ;otherwise compare characters.
EB6D   E6 7F                  AND   7FH   
EB6F   C2 2F EB               JP   NZ,FINDNXT   ;not the same, check next entry.
EB72   C3 7E EB               JP   FNDNXT4   ;so far so good, keep checking.
EB75   C5           FNDNXT3:   PUSH   BC   ;check the extent byte here.
EB76   4E                     LD   C,(HL)   
EB77   CD 09 EB               CALL   SAMEXT   
EB7A   C1                     POP   BC   
EB7B   C2 2F EB               JP   NZ,FINDNXT   ;not the same, look some more.
EB7E                          ; 
EB7E                          ;   So far the names compare. Bump pointers to the next byte
EB7E                          ; and continue until all (C) characters have been checked.
EB7E                          ; 
EB7E   13           FNDNXT4:   INC   DE   ;bump pointers.
EB7F   23                     INC   HL   
EB80   04                     INC   B   
EB81   0D                     DEC   C   ;adjust character counter.
EB82   C3 55 EB               JP   FNDNXT2   
EB85   3A EC F1     FNDNXT5:   LD   A,(FILEPOS)   ;return the position of this entry.
EB88   E6 03                  AND   03H   
EB8A   32 45 E7               LD   (STATUS),A   
EB8D   21 D6 F1               LD   HL,FNDSTAT   
EB90   7E                     LD   A,(HL)   
EB91   17                     RLA   
EB92   D0                     RET   NC   
EB93   AF                     XOR   A   
EB94   77                     LD   (HL),A   
EB95   C9                     RET   
EB96                          ; 
EB96                          ;   Filename was not found. Set appropriate status.
EB96                          ; 
EB96   CD 00 EA     FNDNXT6:   CALL   STFILPOS   ;set (FILEPOS) to 0ffffh.
EB99   3E FF                  LD   A,0FFH   ;say not located.
EB9B   C3 01 E7               JP   SETSTAT   
EB9E                          ; 
EB9E                          ;   Erase files from the directory. Only the first byte of the
EB9E                          ; fcb will be affected. It is set to (E5).
EB9E                          ; 
EB9E   CD 56 E9     ERAFILE:   CALL   CHKWPRT   ;is disk write protected?
EBA1   0E 0C                  LD   C,12   ;only compare file names.
EBA3   CD 1A EB               CALL   FINDFST   ;get first file name.
EBA6   CD F7 E9     ERAFIL1:   CALL   CKFILPOS   ;any found?
EBA9   C8                     RET   Z   ;nope, we must be done.
EBAA   CD 46 E9               CALL   CHKROFL   ;is file read only?
EBAD   CD 60 E9               CALL   FCB2HL   ;nope, get address of fcb and
EBB0   36 E5                  LD   (HL),0E5H   ;set first byte to 'empty'.
EBB2   0E 00                  LD   C,0   ;clear the space from the bit map.
EBB4   CD 6D EA               CALL   SETFILE   
EBB7   CD C8 E9               CALL   DIRWRITE   ;now write the directory sector back out.
EBBA   CD 2F EB               CALL   FINDNXT   ;find the next file name.
EBBD   C3 A6 EB               JP   ERAFIL1   ;and repeat process.
EBC0                          ; 
EBC0                          ;   Look through the space allocation map (bit map) for the
EBC0                          ; next available block. Start searching at block number (BC-1).
EBC0                          ; The search procedure is to look for an empty block that is
EBC0                          ; before the starting block. If not empty, look at a later
EBC0                          ; block number. In this way, we return the closest empty block
EBC0                          ; on either side of the 'target' block number. This will speed
EBC0                          ; access on random devices. For serial devices, this should be
EBC0                          ; changed to look in the forward direction first and then start
EBC0                          ; at the front and search some more.
EBC0                          ; 
EBC0                          ;   On return, (DE)= block number that is empty and (HL) =0
EBC0                          ; if no empry block was found.
EBC0                          ; 
EBC0   50           FNDSPACE:   LD   D,B   ;set (DE) as the block that is checked.
EBC1   59                     LD   E,C   
EBC2                          ; 
EBC2                          ;   Look before target block. Registers (BC) are used as the lower
EBC2                          ; pointer and (DE) as the upper pointer.
EBC2                          ; 
EBC2   79           FNDSPA1:   LD   A,C   ;is block 0 specified?
EBC3   B0                     OR   B   
EBC4   CA D3 EB               JP   Z,FNDSPA2   
EBC7   0B                     DEC   BC   ;nope, check previous block.
EBC8   D5                     PUSH   DE   
EBC9   C5                     PUSH   BC   
EBCA   CD 37 EA               CALL   CKBITMAP   
EBCD   1F                     RRA   ;is this block empty?
EBCE   D2 EE EB               JP   NC,FNDSPA3   ;yes. use this.
EBD1                          ; 
EBD1                          ;   Note that the above logic gets the first block that it finds
EBD1                          ; that is empty. Thus a file could be written 'backward' making
EBD1                          ; it very slow to access. This could be changed to look for the
EBD1                          ; first empty block and then continue until the start of this
EBD1                          ; empty space is located and then used that starting block.
EBD1                          ; This should help speed up access to some files especially on
EBD1                          ; a well used disk with lots of fairly small 'holes'.
EBD1                          ; 
EBD1   C1                     POP   BC   ;nope, check some more.
EBD2   D1                     POP   DE   
EBD3                          ; 
EBD3                          ;   Now look after target block.
EBD3                          ; 
EBD3   2A C8 F1     FNDSPA2:   LD   HL,(DSKSIZE)   ;is block (DE) within disk limits?
EBD6   7B                     LD   A,E   
EBD7   95                     SUB   L   
EBD8   7A                     LD   A,D   
EBD9   9C                     SBC   A,H   
EBDA   D2 F6 EB               JP   NC,FNDSPA4   
EBDD   13                     INC   DE   ;yes, move on to next one.
EBDE   C5                     PUSH   BC   
EBDF   D5                     PUSH   DE   
EBE0   42                     LD   B,D   
EBE1   4B                     LD   C,E   
EBE2   CD 37 EA               CALL   CKBITMAP   ;check it.
EBE5   1F                     RRA   ;empty?
EBE6   D2 EE EB               JP   NC,FNDSPA3   
EBE9   D1                     POP   DE   ;nope, continue searching.
EBEA   C1                     POP   BC   
EBEB   C3 C2 EB               JP   FNDSPA1   
EBEE                          ; 
EBEE                          ;   Empty block found. Set it as used and return with (HL)
EBEE                          ; pointing to it (true?).
EBEE                          ; 
EBEE   17           FNDSPA3:   RLA   ;reset byte.
EBEF   3C                     INC   A   ;and set bit 0.
EBF0   CD 66 EA               CALL   STBMAP1   ;update bit map.
EBF3   E1                     POP   HL   ;set return registers.
EBF4   D1                     POP   DE   
EBF5   C9                     RET   
EBF6                          ; 
EBF6                          ;   Free block was not found. If (BC) is not zero, then we have
EBF6                          ; not checked all of the disk space.
EBF6                          ; 
EBF6   79           FNDSPA4:   LD   A,C   
EBF7   B0                     OR   B   
EBF8   C2 C2 EB               JP   NZ,FNDSPA1   
EBFB   21 00 00               LD   HL,0   ;set 'not found' status.
EBFE   C9                     RET   
EBFF                          ; 
EBFF                          ;   Move a complete fcb entry into the directory and write it.
EBFF                          ; 
EBFF   0E 00        FCBSET:   LD   C,0   
EC01   1E 20                  LD   E,32   ;length of each entry.
EC03                          ; 
EC03                          ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
EC03                          ; fcb in directory starting at relative byte (C). This updated
EC03                          ; directory buffer is then written to the disk.
EC03                          ; 
EC03   D5           UPDATE:   PUSH   DE   
EC04   06 00                  LD   B,0   ;set (BC) to relative byte position.
EC06   2A 43 E7               LD   HL,(PARAMS)   ;get address of fcb.
EC09   09                     ADD   HL,BC   ;compute starting byte.
EC0A   EB                     EX   DE,HL   
EC0B   CD 60 E9               CALL   FCB2HL   ;get address of fcb to update in directory.
EC0E   C1                     POP   BC   ;set (C) to number of bytes to change.
EC0F   CD 4F E7               CALL   DE2HL   
EC12   CD C5 E7     UPDATE1:   CALL   TRKSEC   ;determine the track and sector affected.
EC15   C3 C8 E9               JP   DIRWRITE   ;then write this sector out.
EC18                          ; 
EC18                          ;   Routine to change the name of all files on the disk with a
EC18                          ; specified name. The fcb contains the current name as the
EC18                          ; first 12 characters and the new name 16 bytes into the fcb.
EC18                          ; 
EC18   CD 56 E9     CHGNAMES:   CALL   CHKWPRT   ;check for a write protected disk.
EC1B   0E 0C                  LD   C,12   ;match first 12 bytes of fcb only.
EC1D   CD 1A EB               CALL   FINDFST   ;get first name.
EC20   2A 43 E7               LD   HL,(PARAMS)   ;get address of fcb.
EC23   7E                     LD   A,(HL)   ;get user number.
EC24   11 10 00               LD   DE,16   ;move over to desired name.
EC27   19                     ADD   HL,DE   
EC28   77                     LD   (HL),A   ;keep same user number.
EC29   CD F7 E9     CHGNAM1:   CALL   CKFILPOS   ;any matching file found?
EC2C   C8                     RET   Z   ;no, we must be done.
EC2D   CD 46 E9               CALL   CHKROFL   ;check for read only file.
EC30   0E 10                  LD   C,16   ;start 16 bytes into fcb.
EC32   1E 0C                  LD   E,12   ;and update the first 12 bytes of directory.
EC34   CD 03 EC               CALL   UPDATE   
EC37   CD 2F EB               CALL   FINDNXT   ;get te next file name.
EC3A   C3 29 EC               JP   CHGNAM1   ;and continue.
EC3D                          ; 
EC3D                          ;   Update a files attributes. The procedure is to search for
EC3D                          ; every file with the same name as shown in fcb (ignoring bit 7)
EC3D                          ; and then to update it (which includes bit 7). No other changes
EC3D                          ; are made.
EC3D                          ; 
EC3D   0E 0C        SAVEATTR:   LD   C,12   ;match first 12 bytes.
EC3F   CD 1A EB               CALL   FINDFST   ;look for first filename.
EC42   CD F7 E9     SAVATR1:   CALL   CKFILPOS   ;was one found?
EC45   C8                     RET   Z   ;nope, we must be done.
EC46   0E 00                  LD   C,0   ;yes, update the first 12 bytes now.
EC48   1E 0C                  LD   E,12   
EC4A   CD 03 EC               CALL   UPDATE   ;update filename and write directory.
EC4D   CD 2F EB               CALL   FINDNXT   ;and get the next file.
EC50   C3 42 EC               JP   SAVATR1   ;then continue until done.
EC53                          ; 
EC53                          ;  Open a file (name specified in fcb).
EC53                          ; 
EC53   0E 0F        OPENIT:   LD   C,15   ;compare the first 15 bytes.
EC55   CD 1A EB               CALL   FINDFST   ;get the first one in directory.
EC58   CD F7 E9               CALL   CKFILPOS   ;any at all?
EC5B   C8                     RET   Z   
EC5C   CD A8 E8     OPENIT1:   CALL   SETEXT   ;point to extent byte within users fcb.
EC5F   7E                     LD   A,(HL)   ;and get it.
EC60   F5                     PUSH   AF   ;save it and address.
EC61   E5                     PUSH   HL   
EC62   CD 60 E9               CALL   FCB2HL   ;point to fcb in directory.
EC65   EB                     EX   DE,HL   
EC66   2A 43 E7               LD   HL,(PARAMS)   ;this is the users copy.
EC69   0E 20                  LD   C,32   ;move it into users space.
EC6B   D5                     PUSH   DE   
EC6C   CD 4F E7               CALL   DE2HL   
EC6F   CD 7A E9               CALL   SETS2B7   ;set bit 7 in 's2' byte (unmodified).
EC72   D1                     POP   DE   ;now get the extent byte from this fcb.
EC73   21 0C 00               LD   HL,12   
EC76   19                     ADD   HL,DE   
EC77   4E                     LD   C,(HL)   ;into (C).
EC78   21 0F 00               LD   HL,15   ;now get the record count byte into (B).
EC7B   19                     ADD   HL,DE   
EC7C   46                     LD   B,(HL)   
EC7D   E1                     POP   HL   ;keep the same extent as the user had originally.
EC7E   F1                     POP   AF   
EC7F   77                     LD   (HL),A   
EC80   79                     LD   A,C   ;is it the same as in the directory fcb?
EC81   BE                     CP   (HL)   
EC82   78                     LD   A,B   ;if yes, then use the same record count.
EC83   CA 8D EC               JP   Z,OPENIT2   
EC86   3E 00                  LD   A,0   ;if the user specified an extent greater than
EC88   DA 8D EC               JP   C,OPENIT2   ;the one in the directory, then set record count to 0.
EC8B   3E 80                  LD   A,128   ;otherwise set to maximum.
EC8D   2A 43 E7     OPENIT2:   LD   HL,(PARAMS)   ;set record count in users fcb to (A).
EC90   11 0F 00               LD   DE,15   
EC93   19                     ADD   HL,DE   ;compute relative position.
EC94   77                     LD   (HL),A   ;and set the record count.
EC95   C9                     RET   
EC96                          ; 
EC96                          ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
EC96                          ; point to a zero value (16 bit).
EC96                          ;   Return with zero flag set it (DE) was moved. Registers (DE)
EC96                          ; and (HL) are not changed. However (A) is.
EC96                          ; 
EC96   7E           MOVEWORD:   LD   A,(HL)   ;check for a zero word.
EC97   23                     INC   HL   
EC98   B6                     OR   (HL)   ;both bytes zero?
EC99   2B                     DEC   HL   
EC9A   C0                     RET   NZ   ;nope, just return.
EC9B   1A                     LD   A,(DE)   ;yes, move two bytes from (DE) into
EC9C   77                     LD   (HL),A   ;this zero space.
EC9D   13                     INC   DE   
EC9E   23                     INC   HL   
EC9F   1A                     LD   A,(DE)   
ECA0   77                     LD   (HL),A   
ECA1   1B                     DEC   DE   ;don't disturb these registers.
ECA2   2B                     DEC   HL   
ECA3   C9                     RET   
ECA4                          ; 
ECA4                          ;   Get here to close a file specified by (fcb).
ECA4                          ; 
ECA4   AF           CLOSEIT:   XOR   A   ;clear status and file position bytes.
ECA5   32 45 E7               LD   (STATUS),A   
ECA8   32 EC F1               LD   (FILEPOS),A   
ECAB   32 ED F1               LD   (FILEPOS+1),A   
ECAE   CD 20 E9               CALL   GETWPRT   ;get write protect bit for this drive.
ECB1   C0                     RET   NZ   ;just return if it is set.
ECB2   CD 6B E9               CALL   GETS2   ;else get the 's2' byte.
ECB5   E6 80                  AND   80H   ;and look at bit 7 (file unmodified?).
ECB7   C0                     RET   NZ   ;just return if set.
ECB8   0E 0F                  LD   C,15   ;else look up this file in directory.
ECBA   CD 1A EB               CALL   FINDFST   
ECBD   CD F7 E9               CALL   CKFILPOS   ;was it found?
ECC0   C8                     RET   Z   ;just return if not.
ECC1   01 10 00               LD   BC,16   ;set (HL) pointing to records used section.
ECC4   CD 60 E9               CALL   FCB2HL   
ECC7   09                     ADD   HL,BC   
ECC8   EB                     EX   DE,HL   
ECC9   2A 43 E7               LD   HL,(PARAMS)   ;do the same for users specified fcb.
ECCC   09                     ADD   HL,BC   
ECCD   0E 10                  LD   C,16   ;this many bytes are present in this extent.
ECCF   3A DF F1     CLOSEIT1:   LD   A,(BIGDISK)   ;8 or 16 bit record numbers?
ECD2   B7                     OR   A   
ECD3   CA EA EC               JP   Z,CLOSEIT4   
ECD6   7E                     LD   A,(HL)   ;just 8 bit. Get one from users fcb.
ECD7   B7                     OR   A   
ECD8   1A                     LD   A,(DE)   ;now get one from directory fcb.
ECD9   C2 DD EC               JP   NZ,CLOSEIT2   
ECDC   77                     LD   (HL),A   ;users byte was zero. Update from directory.
ECDD   B7           CLOSEIT2:   OR   A   
ECDE   C2 E3 EC               JP   NZ,CLOSEIT3   
ECE1   7E                     LD   A,(HL)   ;directories byte was zero, update from users fcb.
ECE2   12                     LD   (DE),A   
ECE3   BE           CLOSEIT3:   CP   (HL)   ;if neither one of these bytes were zero,
ECE4   C2 21 ED               JP   NZ,CLOSEIT7   ;then close error if they are not the same.
ECE7   C3 FF EC               JP   CLOSEIT5   ;ok so far, get to next byte in fcbs.
ECEA   CD 96 EC     CLOSEIT4:   CALL   MOVEWORD   ;update users fcb if it is zero.
ECED   EB                     EX   DE,HL   
ECEE   CD 96 EC               CALL   MOVEWORD   ;update directories fcb if it is zero.
ECF1   EB                     EX   DE,HL   
ECF2   1A                     LD   A,(DE)   ;if these two values are no different,
ECF3   BE                     CP   (HL)   ;then a close error occured.
ECF4   C2 21 ED               JP   NZ,CLOSEIT7   
ECF7   13                     INC   DE   ;check second byte.
ECF8   23                     INC   HL   
ECF9   1A                     LD   A,(DE)   
ECFA   BE                     CP   (HL)   
ECFB   C2 21 ED               JP   NZ,CLOSEIT7   
ECFE   0D                     DEC   C   ;remember 16 bit values.
ECFF   13           CLOSEIT5:   INC   DE   ;bump to next item in table.
ED00   23                     INC   HL   
ED01   0D                     DEC   C   ;there are 16 entries only.
ED02   C2 CF EC               JP   NZ,CLOSEIT1   ;continue if more to do.
ED05   01 EC FF               LD   BC,0FFECH   ;backup 20 places (extent byte).
ED08   09                     ADD   HL,BC   
ED09   EB                     EX   DE,HL   
ED0A   09                     ADD   HL,BC   
ED0B   1A                     LD   A,(DE)   
ED0C   BE                     CP   (HL)   ;directory's extent already greater than the
ED0D   DA 19 ED               JP   C,CLOSEIT6   ;users extent?
ED10   77                     LD   (HL),A   ;no, update directory extent.
ED11   01 03 00               LD   BC,3   ;and update the record count byte in
ED14   09                     ADD   HL,BC   ;directories fcb.
ED15   EB                     EX   DE,HL   
ED16   09                     ADD   HL,BC   
ED17   7E                     LD   A,(HL)   ;get from user.
ED18   12                     LD   (DE),A   ;and put in directory.
ED19   3E FF        CLOSEIT6:   LD   A,0FFH   ;set 'was open and is now closed' byte.
ED1B   32 D4 F1               LD   (CLOSEFLG),A   
ED1E   C3 12 EC               JP   UPDATE1   ;update the directory now.
ED21   21 45 E7     CLOSEIT7:   LD   HL,STATUS   ;set return status and then return.
ED24   35                     DEC   (HL)   
ED25   C9                     RET   
ED26                          ; 
ED26                          ;   Routine to get the next empty space in the directory. It
ED26                          ; will then be cleared for use.
ED26                          ; 
ED26   CD 56 E9     GETEMPTY:   CALL   CHKWPRT   ;make sure disk is not write protected.
ED29   2A 43 E7               LD   HL,(PARAMS)   ;save current parameters (fcb).
ED2C   E5                     PUSH   HL   
ED2D   21 AE F1               LD   HL,EMPTYFCB   ;use special one for empty space.
ED30   22 43 E7               LD   (PARAMS),HL   
ED33   0E 01                  LD   C,1   ;search for first empty spot in directory.
ED35   CD 1A EB               CALL   FINDFST   ;(* only check first byte *)
ED38   CD F7 E9               CALL   CKFILPOS   ;none?
ED3B   E1                     POP   HL   
ED3C   22 43 E7               LD   (PARAMS),HL   ;restore original fcb address.
ED3F   C8                     RET   Z   ;return if no more space.
ED40   EB                     EX   DE,HL   
ED41   21 0F 00               LD   HL,15   ;point to number of records for this file.
ED44   19                     ADD   HL,DE   
ED45   0E 11                  LD   C,17   ;and clear all of this space.
ED47   AF                     XOR   A   
ED48   77           GETMT1:   LD   (HL),A   
ED49   23                     INC   HL   
ED4A   0D                     DEC   C   
ED4B   C2 48 ED               JP   NZ,GETMT1   
ED4E   21 0D 00               LD   HL,13   ;clear the 's1' byte also.
ED51   19                     ADD   HL,DE   
ED52   77                     LD   (HL),A   
ED53   CD 8E E9               CALL   CHKNMBR   ;keep (SCRATCH1) within bounds.
ED56   CD FF EB               CALL   FCBSET   ;write out this fcb entry to directory.
ED59   C3 7A E9               JP   SETS2B7   ;set 's2' byte bit 7 (unmodified at present).
ED5C                          ; 
ED5C                          ;   Routine to close the current extent and open the next one
ED5C                          ; for reading.
ED5C                          ; 
ED5C   AF           GETNEXT:   XOR   A   
ED5D   32 D4 F1               LD   (CLOSEFLG),A   ;clear close flag.
ED60   CD A4 EC               CALL   CLOSEIT   ;close this extent.
ED63   CD F7 E9               CALL   CKFILPOS   
ED66   C8                     RET   Z   ;not there???
ED67   2A 43 E7               LD   HL,(PARAMS)   ;get extent byte.
ED6A   01 0C 00               LD   BC,12   
ED6D   09                     ADD   HL,BC   
ED6E   7E                     LD   A,(HL)   ;and increment it.
ED6F   3C                     INC   A   
ED70   E6 1F                  AND   1FH   ;keep within range 0-31.
ED72   77                     LD   (HL),A   
ED73   CA 85 ED               JP   Z,GTNEXT1   ;overflow?
ED76   47                     LD   B,A   ;mask extent byte.
ED77   3A C7 F1               LD   A,(EXTMASK)   
ED7A   A0                     AND   B   
ED7B   21 D4 F1               LD   HL,CLOSEFLG   ;check close flag (0ffh is ok).
ED7E   A6                     AND   (HL)   
ED7F   CA 90 ED               JP   Z,GTNEXT2   ;if zero, we must read in next extent.
ED82   C3 AE ED               JP   GTNEXT3   ;else, it is already in memory.
ED85   01 02 00     GTNEXT1:   LD   BC,2   ;Point to the 's2' byte.
ED88   09                     ADD   HL,BC   
ED89   34                     INC   (HL)   ;and bump it.
ED8A   7E                     LD   A,(HL)   ;too many extents?
ED8B   E6 0F                  AND   0FH   
ED8D   CA B8 ED               JP   Z,GTNEXT5   ;yes, set error code.
ED90                          ; 
ED90                          ;   Get here to open the next extent.
ED90                          ; 
ED90   0E 0F        GTNEXT2:   LD   C,15   ;set to check first 15 bytes of fcb.
ED92   CD 1A EB               CALL   FINDFST   ;find the first one.
ED95   CD F7 E9               CALL   CKFILPOS   ;none available?
ED98   C2 AE ED               JP   NZ,GTNEXT3   
ED9B   3A D5 F1               LD   A,(RDWRTFLG)   ;no extent present. Can we open an empty one?
ED9E   3C                     INC   A   ;0ffh means reading (so not possible).
ED9F   CA B8 ED               JP   Z,GTNEXT5   ;or an error.
EDA2   CD 26 ED               CALL   GETEMPTY   ;we are writing, get an empty entry.
EDA5   CD F7 E9               CALL   CKFILPOS   ;none?
EDA8   CA B8 ED               JP   Z,GTNEXT5   ;error if true.
EDAB   C3 B1 ED               JP   GTNEXT4   ;else we are almost done.
EDAE   CD 5C EC     GTNEXT3:   CALL   OPENIT1   ;open this extent.
EDB1   CD BD E8     GTNEXT4:   CALL   STRDATA   ;move in updated data (rec #, extent #, etc.)
EDB4   AF                     XOR   A   ;clear status and return.
EDB5   C3 01 E7               JP   SETSTAT   
EDB8                          ; 
EDB8                          ;   Error in extending the file. Too many extents were needed
EDB8                          ; or not enough space on the disk.
EDB8                          ; 
EDB8   CD 05 E7     GTNEXT5:   CALL   IOERR1   ;set error code, clear bit 7 of 's2'
EDBB   C3 7A E9               JP   SETS2B7   ;so this is not written on a close.
EDBE                          ; 
EDBE                          ;   Read a sequential file.
EDBE                          ; 
EDBE   3E 01        RDSEQ:    LD   A,1   ;set sequential access mode.
EDC0   32 D7 F1               LD   (MODE),A   
EDC3   3E FF        RDSEQ1:   LD   A,0FFH   ;don't allow reading unwritten space.
EDC5   32 D5 F1               LD   (RDWRTFLG),A   
EDC8   CD BD E8               CALL   STRDATA   ;put rec# and ext# into fcb.
EDCB   3A E5 F1               LD   A,(SAVNREC)   ;get next record to read.
EDCE   21 E3 F1               LD   HL,SAVNXT   ;get number of records in extent.
EDD1   BE                     CP   (HL)   ;within this extent?
EDD2   DA E8 ED               JP   C,RDSEQ2   
EDD5   FE 80                  CP   128   ;no. Is this extent fully used?
EDD7   C2 FD ED               JP   NZ,RDSEQ3   ;no. End-of-file.
EDDA   CD 5C ED               CALL   GETNEXT   ;yes, open the next one.
EDDD   AF                     XOR   A   ;reset next record to read.
EDDE   32 E5 F1               LD   (SAVNREC),A   
EDE1   3A 45 E7               LD   A,(STATUS)   ;check on open, successful?
EDE4   B7                     OR   A   
EDE5   C2 FD ED               JP   NZ,RDSEQ3   ;no, error.
EDE8   CD 79 E8     RDSEQ2:   CALL   COMBLK   ;ok. compute block number to read.
EDEB   CD 86 E8               CALL   CHKBLK   ;check it. Within bounds?
EDEE   CA FD ED               JP   Z,RDSEQ3   ;no, error.
EDF1   CD 8C E8               CALL   LOGICAL   ;convert (BLKNMBR) to logical sector (128 byte).
EDF4   CD D3 E7               CALL   TRKSEC1   ;set the track and sector for this block #.
EDF7   CD B4 E7               CALL   DOREAD   ;and read it.
EDFA   C3 D4 E8               JP   SETNREC   ;and set the next record to be accessed.
EDFD                          ; 
EDFD                          ;   Read error occured. Set status and return.
EDFD                          ; 
EDFD   C3 05 E7     RDSEQ3:   JP   IOERR1   
EE00                          ; 
EE00                          ;   Write the next sequential record.
EE00                          ; 
EE00   3E 01        WTSEQ:    LD   A,1   ;set sequential access mode.
EE02   32 D7 F1               LD   (MODE),A   
EE05   3E 00        WTSEQ1:   LD   A,0   ;allow an addition empty extent to be opened.
EE07   32 D5 F1               LD   (RDWRTFLG),A   
EE0A   CD 56 E9               CALL   CHKWPRT   ;check write protect status.
EE0D   2A 43 E7               LD   HL,(PARAMS)   
EE10   CD 49 E9               CALL   CKROF1   ;check for read only file, (HL) already set to fcb.
EE13   CD BD E8               CALL   STRDATA   ;put updated data into fcb.
EE16   3A E5 F1               LD   A,(SAVNREC)   ;get record number to write.
EE19   FE 80                  CP   128   ;within range?
EE1B   D2 05 E7               JP   NC,IOERR1   ;no, error(?).
EE1E   CD 79 E8               CALL   COMBLK   ;compute block number.
EE21   CD 86 E8               CALL   CHKBLK   ;check number.
EE24   0E 00                  LD   C,0   ;is there one to write to?
EE26   C2 70 EE               JP   NZ,WTSEQ6   ;yes, go do it.
EE29   CD 40 E8               CALL   GETBLOCK   ;get next block number within fcb to use.
EE2C   32 D9 F1               LD   (RELBLOCK),A   ;and save.
EE2F   01 00 00               LD   BC,0   ;start looking for space from the start
EE32   B7                     OR   A   ;if none allocated as yet.
EE33   CA 3D EE               JP   Z,WTSEQ2   
EE36   4F                     LD   C,A   ;extract previous block number from fcb
EE37   0B                     DEC   BC   ;so we can be closest to it.
EE38   CD 60 E8               CALL   EXTBLK   
EE3B   44                     LD   B,H   
EE3C   4D                     LD   C,L   
EE3D   CD C0 EB     WTSEQ2:   CALL   FNDSPACE   ;find the next empty block nearest number (BC).
EE40   7D                     LD   A,L   ;check for a zero number.
EE41   B4                     OR   H   
EE42   C2 4A EE               JP   NZ,WTSEQ3   
EE45   3E 02                  LD   A,2   ;no more space?
EE47   C3 01 E7               JP   SETSTAT   
EE4A   22 E7 F1     WTSEQ3:   LD   (BLKNMBR),HL   ;save block number to access.
EE4D   EB                     EX   DE,HL   ;put block number into (DE).
EE4E   2A 43 E7               LD   HL,(PARAMS)   ;now we must update the fcb for this
EE51   01 10 00               LD   BC,16   ;newly allocated block.
EE54   09                     ADD   HL,BC   
EE55   3A DF F1               LD   A,(BIGDISK)   ;8 or 16 bit block numbers?
EE58   B7                     OR   A   
EE59   3A D9 F1               LD   A,(RELBLOCK)   ;(* update this entry *)
EE5C   CA 66 EE               JP   Z,WTSEQ4   ;zero means 16 bit ones.
EE5F   CD 66 E9               CALL   ADDA2HL   ;(HL)=(HL)+(A)
EE62   73                     LD   (HL),E   ;store new block number.
EE63   C3 6E EE               JP   WTSEQ5   
EE66   4F           WTSEQ4:   LD   C,A   ;compute spot in this 16 bit table.
EE67   06 00                  LD   B,0   
EE69   09                     ADD   HL,BC   
EE6A   09                     ADD   HL,BC   
EE6B   73                     LD   (HL),E   ;stuff block number (DE) there.
EE6C   23                     INC   HL   
EE6D   72                     LD   (HL),D   
EE6E   0E 02        WTSEQ5:   LD   C,2   ;set (C) to indicate writing to un-used disk space.
EE70   3A 45 E7     WTSEQ6:   LD   A,(STATUS)   ;are we ok so far?
EE73   B7                     OR   A   
EE74   C0                     RET   NZ   
EE75   C5                     PUSH   BC   ;yes, save write flag for bios (register C).
EE76   CD 8C E8               CALL   LOGICAL   ;convert (BLKNMBR) over to loical sectors.
EE79   3A D7 F1               LD   A,(MODE)   ;get access mode flag (1=sequential,
EE7C   3D                     DEC   A   ;0=random, 2=special?).
EE7D   3D                     DEC   A   
EE7E   C2 BD EE               JP   NZ,WTSEQ9   
EE81                          ; 
EE81                          ;   Special random i/o from function #40. Maybe for M/PM, but the
EE81                          ; current block, if it has not been written to, will be zeroed
EE81                          ; out and then written (reason?).
EE81                          ; 
EE81   C1                     POP   BC   
EE82   C5                     PUSH   BC   
EE83   79                     LD   A,C   ;get write status flag (2=writing unused space).
EE84   3D                     DEC   A   
EE85   3D                     DEC   A   
EE86   C2 BD EE               JP   NZ,WTSEQ9   
EE89   E5                     PUSH   HL   
EE8A   2A BB F1               LD   HL,(DIRBUF)   ;zero out the directory buffer.
EE8D   57                     LD   D,A   ;note that (A) is zero here.
EE8E   77           WTSEQ7:   LD   (HL),A   
EE8F   23                     INC   HL   
EE90   14                     INC   D   ;do 128 bytes.
EE91   F2 8E EE               JP   P,WTSEQ7   
EE94   CD E2 E9               CALL   DIRDMA   ;tell the bios the dma address for directory access.
EE97   2A E9 F1               LD   HL,(LOGSECT)   ;get sector that starts current block.
EE9A   0E 02                  LD   C,2   ;set 'writing to unused space' flag.
EE9C   22 E7 F1     WTSEQ8:   LD   (BLKNMBR),HL   ;save sector to write.
EE9F   C5                     PUSH   BC   
EEA0   CD D3 E7               CALL   TRKSEC1   ;determine its track and sector numbers.
EEA3   C1                     POP   BC   
EEA4   CD BA E7               CALL   DOWRITE   ;now write out 128 bytes of zeros.
EEA7   2A E7 F1               LD   HL,(BLKNMBR)   ;get sector number.
EEAA   0E 00                  LD   C,0   ;set normal write flag.
EEAC   3A C6 F1               LD   A,(BLKMASK)   ;determine if we have written the entire
EEAF   47                     LD   B,A   ;physical block.
EEB0   A5                     AND   L   
EEB1   B8                     CP   B   
EEB2   23                     INC   HL   ;prepare for the next one.
EEB3   C2 9C EE               JP   NZ,WTSEQ8   ;continue until (BLKMASK+1) sectors written.
EEB6   E1                     POP   HL   ;reset next sector number.
EEB7   22 E7 F1               LD   (BLKNMBR),HL   
EEBA   CD DC E9               CALL   DEFDMA   ;and reset dma address.
EEBD                          ; 
EEBD                          ;   Normal disk write. Set the desired track and sector then
EEBD                          ; do the actual write.
EEBD                          ; 
EEBD   CD D3 E7     WTSEQ9:   CALL   TRKSEC1   ;determine track and sector for this write.
EEC0   C1                     POP   BC   ;get write status flag.
EEC1   C5                     PUSH   BC   
EEC2   CD BA E7               CALL   DOWRITE   ;and write this out.
EEC5   C1                     POP   BC   
EEC6   3A E5 F1               LD   A,(SAVNREC)   ;get number of records in file.
EEC9   21 E3 F1               LD   HL,SAVNXT   ;get last record written.
EECC   BE                     CP   (HL)   
EECD   DA D4 EE               JP   C,WTSEQ10   
EED0   77                     LD   (HL),A   ;we have to update record count.
EED1   34                     INC   (HL)   
EED2   0E 02                  LD   C,2   
EED4                          ; 
EED4                          ;*   This area has been patched to correct disk update problem
EED4                          ;* when using blocking and de-blocking in the BIOS.
EED4                          ; 
EED4   00           WTSEQ10:   NOP   ;was 'dcr c'
EED5   00                     NOP   ;was 'dcr c'
EED6   21 00 00               LD   HL,0   ;was 'jnz wtseq99'
EED9                          ; 
EED9                          ; *   End of patch.
EED9                          ; 
EED9   F5                     PUSH   AF   
EEDA   CD 6B E9               CALL   GETS2   ;set 'extent written to' flag.
EEDD   E6 7F                  AND   7FH   ;(* clear bit 7 *)
EEDF   77                     LD   (HL),A   
EEE0   F1                     POP   AF   ;get record count for this extent.
EEE1   FE 7F        WTSEQ99:   CP   127   ;is it full?
EEE3   C2 02 EF               JP   NZ,WTSEQ12   
EEE6   3A D7 F1               LD   A,(MODE)   ;yes, are we in sequential mode?
EEE9   FE 01                  CP   1   
EEEB   C2 02 EF               JP   NZ,WTSEQ12   
EEEE   CD D4 E8               CALL   SETNREC   ;yes, set next record number.
EEF1   CD 5C ED               CALL   GETNEXT   ;and get next empty space in directory.
EEF4   21 45 E7               LD   HL,STATUS   ;ok?
EEF7   7E                     LD   A,(HL)   
EEF8   B7                     OR   A   
EEF9   C2 00 EF               JP   NZ,WTSEQ11   
EEFC   3D                     DEC   A   ;yes, set record count to -1.
EEFD   32 E5 F1               LD   (SAVNREC),A   
EF00   36 00        WTSEQ11:   LD   (HL),0   ;clear status.
EF02   C3 D4 E8     WTSEQ12:   JP   SETNREC   ;set next record to access.
EF05                          ; 
EF05                          ;   For random i/o, set the fcb for the desired record number
EF05                          ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
EF05                          ; used as follows:
EF05                          ; 
EF05                          ;       fcb+35            fcb+34            fcb+33
EF05                          ;  |     'r-2'      |      'r-1'      |      'r-0'     |
EF05                          ;  |7             0 | 7             0 | 7             0|
EF05                          ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
EF05                          ;  |    overflow   | | extra |  extent   |   record #  |
EF05                          ;  | ______________| |_extent|__number___|_____________|
EF05                          ;                     also 's2'
EF05                          ; 
EF05                          ;   On entry, register (C) contains 0ffh if this is a read
EF05                          ; and thus we can not access unwritten disk space. Otherwise,
EF05                          ; another extent will be opened (for writing) if required.
EF05                          ; 
EF05   AF           POSITION:   XOR   A   ;set random i/o flag.
EF06   32 D7 F1               LD   (MODE),A   
EF09                          ; 
EF09                          ;   Special entry (function #40). M/PM ?
EF09                          ; 
EF09   C5           POSITN1:   PUSH   BC   ;save read/write flag.
EF0A   2A 43 E7               LD   HL,(PARAMS)   ;get address of fcb.
EF0D   EB                     EX   DE,HL   
EF0E   21 21 00               LD   HL,33   ;now get byte 'r0'.
EF11   19                     ADD   HL,DE   
EF12   7E                     LD   A,(HL)   
EF13   E6 7F                  AND   7FH   ;keep bits 0-6 for the record number to access.
EF15   F5                     PUSH   AF   
EF16   7E                     LD   A,(HL)   ;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
EF17   17                     RLA   
EF18   23                     INC   HL   
EF19   7E                     LD   A,(HL)   
EF1A   17                     RLA   
EF1B   E6 1F                  AND   1FH   ;and save this in bits 0-4 of (C).
EF1D   4F                     LD   C,A   ;this is the extent byte.
EF1E   7E                     LD   A,(HL)   ;now get the extra extent byte.
EF1F   1F                     RRA   
EF20   1F                     RRA   
EF21   1F                     RRA   
EF22   1F                     RRA   
EF23   E6 0F                  AND   0FH   
EF25   47                     LD   B,A   ;and save it in (B).
EF26   F1                     POP   AF   ;get record number back to (A).
EF27   23                     INC   HL   ;check overflow byte 'r2'.
EF28   6E                     LD   L,(HL)   
EF29   2C                     INC   L   
EF2A   2D                     DEC   L   
EF2B   2E 06                  LD   L,6   ;prepare for error.
EF2D   C2 8D EF               JP   NZ,POSITN5   ;out of disk space error.
EF30   21 20 00               LD   HL,32   ;store record number into fcb.
EF33   19                     ADD   HL,DE   
EF34   77                     LD   (HL),A   
EF35   21 0C 00               LD   HL,12   ;and now check the extent byte.
EF38   19                     ADD   HL,DE   
EF39   79                     LD   A,C   
EF3A   96                     SUB   (HL)   ;same extent as before?
EF3B   C2 49 EF               JP   NZ,POSITN2   
EF3E   21 0E 00               LD   HL,14   ;yes, check extra extent byte 's2' also.
EF41   19                     ADD   HL,DE   
EF42   78                     LD   A,B   
EF43   96                     SUB   (HL)   
EF44   E6 7F                  AND   7FH   
EF46   CA 81 EF               JP   Z,POSITN3   ;same, we are almost done then.
EF49                          ; 
EF49                          ;  Get here when another extent is required.
EF49                          ; 
EF49   C5           POSITN2:   PUSH   BC   
EF4A   D5                     PUSH   DE   
EF4B   CD A4 EC               CALL   CLOSEIT   ;close current extent.
EF4E   D1                     POP   DE   
EF4F   C1                     POP   BC   
EF50   2E 03                  LD   L,3   ;prepare for error.
EF52   3A 45 E7               LD   A,(STATUS)   
EF55   3C                     INC   A   
EF56   CA 86 EF               JP   Z,POSITN4   ;close error.
EF59   21 0C 00               LD   HL,12   ;put desired extent into fcb now.
EF5C   19                     ADD   HL,DE   
EF5D   71                     LD   (HL),C   
EF5E   21 0E 00               LD   HL,14   ;and store extra extent byte 's2'.
EF61   19                     ADD   HL,DE   
EF62   70                     LD   (HL),B   
EF63   CD 53 EC               CALL   OPENIT   ;try and get this extent.
EF66   3A 45 E7               LD   A,(STATUS)   ;was it there?
EF69   3C                     INC   A   
EF6A   C2 81 EF               JP   NZ,POSITN3   
EF6D   C1                     POP   BC   ;no. can we create a new one (writing?).
EF6E   C5                     PUSH   BC   
EF6F   2E 04                  LD   L,4   ;prepare for error.
EF71   0C                     INC   C   
EF72   CA 86 EF               JP   Z,POSITN4   ;nope, reading unwritten space error.
EF75   CD 26 ED               CALL   GETEMPTY   ;yes we can, try to find space.
EF78   2E 05                  LD   L,5   ;prepare for error.
EF7A   3A 45 E7               LD   A,(STATUS)   
EF7D   3C                     INC   A   
EF7E   CA 86 EF               JP   Z,POSITN4   ;out of space?
EF81                          ; 
EF81                          ;   Normal return location. Clear error code and return.
EF81                          ; 
EF81   C1           POSITN3:   POP   BC   ;restore stack.
EF82   AF                     XOR   A   ;and clear error code byte.
EF83   C3 01 E7               JP   SETSTAT   
EF86                          ; 
EF86                          ;   Error. Set the 's2' byte to indicate this (why?).
EF86                          ; 
EF86   E5           POSITN4:   PUSH   HL   
EF87   CD 6B E9               CALL   GETS2   
EF8A   36 C0                  LD   (HL),0C0H   
EF8C   E1                     POP   HL   
EF8D                          ; 
EF8D                          ;   Return with error code (presently in L).
EF8D                          ; 
EF8D   C1           POSITN5:   POP   BC   
EF8E   7D                     LD   A,L   ;get error code.
EF8F   32 45 E7               LD   (STATUS),A   
EF92   C3 7A E9               JP   SETS2B7   
EF95                          ; 
EF95                          ;   Read a random record.
EF95                          ; 
EF95   0E FF        READRAN:   LD   C,0FFH   ;set 'read' status.
EF97   CD 05 EF               CALL   POSITION   ;position the file to proper record.
EF9A   CC C3 ED               CALL   Z,RDSEQ1   ;and read it as usual (if no errors).
EF9D   C9                     RET   
EF9E                          ; 
EF9E                          ;   Write to a random record.
EF9E                          ; 
EF9E   0E 00        WRITERAN:   LD   C,0   ;set 'writing' flag.
EFA0   CD 05 EF               CALL   POSITION   ;position the file to proper record.
EFA3   CC 05 EE               CALL   Z,WTSEQ1   ;and write as usual (if no errors).
EFA6   C9                     RET   
EFA7                          ; 
EFA7                          ;   Compute the random record number. Enter with (HL) pointing
EFA7                          ; to a fcb an (DE) contains a relative location of a record
EFA7                          ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
EFA7                          ; byte, and (A) the 'r2' byte.
EFA7                          ; 
EFA7                          ;   On return, the zero flag is set if the record is within
EFA7                          ; bounds. Otherwise, an overflow occured.
EFA7                          ; 
EFA7   EB           COMPRAND:   EX   DE,HL   ;save fcb pointer in (DE).
EFA8   19                     ADD   HL,DE   ;compute relative position of record #.
EFA9   4E                     LD   C,(HL)   ;get record number into (BC).
EFAA   06 00                  LD   B,0   
EFAC   21 0C 00               LD   HL,12   ;now get extent.
EFAF   19                     ADD   HL,DE   
EFB0   7E                     LD   A,(HL)   ;compute (BC)=(record #)+(extent)*128.
EFB1   0F                     RRCA   ;move lower bit into bit 7.
EFB2   E6 80                  AND   80H   ;and ignore all other bits.
EFB4   81                     ADD   A,C   ;add to our record number.
EFB5   4F                     LD   C,A   
EFB6   3E 00                  LD   A,0   ;take care of any carry.
EFB8   88                     ADC   A,B   
EFB9   47                     LD   B,A   
EFBA   7E                     LD   A,(HL)   ;now get the upper bits of extent into
EFBB   0F                     RRCA   ;bit positions 0-3.
EFBC   E6 0F                  AND   0FH   ;and ignore all others.
EFBE   80                     ADD   A,B   ;add this in to 'r1' byte.
EFBF   47                     LD   B,A   
EFC0   21 0E 00               LD   HL,14   ;get the 's2' byte (extra extent).
EFC3   19                     ADD   HL,DE   
EFC4   7E                     LD   A,(HL)   
EFC5   87                     ADD   A,A   ;and shift it left 4 bits (bits 4-7).
EFC6   87                     ADD   A,A   
EFC7   87                     ADD   A,A   
EFC8   87                     ADD   A,A   
EFC9   F5                     PUSH   AF   ;save carry flag (bit 0 of flag byte).
EFCA   80                     ADD   A,B   ;now add extra extent into 'r1'.
EFCB   47                     LD   B,A   
EFCC   F5                     PUSH   AF   ;and save carry (overflow byte 'r2').
EFCD   E1                     POP   HL   ;bit 0 of (L) is the overflow indicator.
EFCE   7D                     LD   A,L   
EFCF   E1                     POP   HL   ;and same for first carry flag.
EFD0   B5                     OR   L   ;either one of these set?
EFD1   E6 01                  AND   01H   ;only check the carry flags.
EFD3   C9                     RET   
EFD4                          ; 
EFD4                          ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
EFD4                          ; reflect the last record used for a random (or other) file.
EFD4                          ; This reads the directory and looks at all extents computing
EFD4                          ; the largerst record number for each and keeping the maximum
EFD4                          ; value only. Then 'r0', 'r1', and 'r2' will reflect this
EFD4                          ; maximum record number. This is used to compute the space used
EFD4                          ; by a random file.
EFD4                          ; 
EFD4   0E 0C        RANSIZE:   LD   C,12   ;look thru directory for first entry with
EFD6   CD 1A EB               CALL   FINDFST   ;this name.
EFD9   2A 43 E7               LD   HL,(PARAMS)   ;zero out the 'r0, r1, r2' bytes.
EFDC   11 21 00               LD   DE,33   
EFDF   19                     ADD   HL,DE   
EFE0   E5                     PUSH   HL   
EFE1   72                     LD   (HL),D   ;note that (D)=0.
EFE2   23                     INC   HL   
EFE3   72                     LD   (HL),D   
EFE4   23                     INC   HL   
EFE5   72                     LD   (HL),D   
EFE6   CD F7 E9     RANSIZ1:   CALL   CKFILPOS   ;is there an extent to process?
EFE9   CA 0E F0               JP   Z,RANSIZ3   ;no, we are done.
EFEC   CD 60 E9               CALL   FCB2HL   ;set (HL) pointing to proper fcb in dir.
EFEF   11 0F 00               LD   DE,15   ;point to last record in extent.
EFF2   CD A7 EF               CALL   COMPRAND   ;and compute random parameters.
EFF5   E1                     POP   HL   
EFF6   E5                     PUSH   HL   ;now check these values against those
EFF7   5F                     LD   E,A   ;already in fcb.
EFF8   79                     LD   A,C   ;the carry flag will be set if those
EFF9   96                     SUB   (HL)   ;in the fcb represent a larger size than
EFFA   23                     INC   HL   ;this extent does.
EFFB   78                     LD   A,B   
EFFC   9E                     SBC   A,(HL)   
EFFD   23                     INC   HL   
EFFE   7B                     LD   A,E   
EFFF   9E                     SBC   A,(HL)   
F000   DA 08 F0               JP   C,RANSIZ2   
F003   73                     LD   (HL),E   ;we found a larger (in size) extent.
F004   2B                     DEC   HL   ;stuff these values into fcb.
F005   70                     LD   (HL),B   
F006   2B                     DEC   HL   
F007   71                     LD   (HL),C   
F008   CD 2F EB     RANSIZ2:   CALL   FINDNXT   ;now get the next extent.
F00B   C3 E6 EF               JP   RANSIZ1   ;continue til all done.
F00E   E1           RANSIZ3:   POP   HL   ;we are done, restore the stack and
F00F   C9                     RET   ;return.
F010                          ; 
F010                          ;   Function to return the random record position of a given
F010                          ; file which has been read in sequential mode up to now.
F010                          ; 
F010   2A 43 E7     SETRAN:   LD   HL,(PARAMS)   ;point to fcb.
F013   11 20 00               LD   DE,32   ;and to last used record.
F016   CD A7 EF               CALL   COMPRAND   ;compute random position.
F019   21 21 00               LD   HL,33   ;now stuff these values into fcb.
F01C   19                     ADD   HL,DE   
F01D   71                     LD   (HL),C   ;move 'r0'.
F01E   23                     INC   HL   
F01F   70                     LD   (HL),B   ;and 'r1'.
F020   23                     INC   HL   
F021   77                     LD   (HL),A   ;and lastly 'r2'.
F022   C9                     RET   
F023                          ; 
F023                          ;   This routine select the drive specified in (ACTIVE) and
F023                          ; update the login vector and bitmap table if this drive was
F023                          ; not already active.
F023                          ; 
F023   2A B1 F1     LOGINDRV:   LD   HL,(LOGIN)   ;get the login vector.
F026   3A 42 E7               LD   A,(ACTIVE)   ;get the default drive.
F029   4F                     LD   C,A   
F02A   CD EC E8               CALL   SHIFTR   ;position active bit for this drive
F02D   E5                     PUSH   HL   ;into bit 0.
F02E   EB                     EX   DE,HL   
F02F   CD 59 E7               CALL   SELECT   ;select this drive.
F032   E1                     POP   HL   
F033   CC 47 E7               CALL   Z,SLCTERR   ;valid drive?
F036   7D                     LD   A,L   ;is this a newly activated drive?
F037   1F                     RRA   
F038   D8                     RET   C   
F039   2A B1 F1               LD   HL,(LOGIN)   ;yes, update the login vector.
F03C   4D                     LD   C,L   
F03D   44                     LD   B,H   
F03E   CD 0D E9               CALL   SETBIT   
F041   22 B1 F1               LD   (LOGIN),HL   ;and save.
F044   C3 A5 EA               JP   BITMAP   ;now update the bitmap.
F047                          ; 
F047                          ;   Function to set the active disk number.
F047                          ; 
F047   3A D8 F1     SETDSK:   LD   A,(EPARAM)   ;get parameter passed and see if this
F04A   21 42 E7               LD   HL,ACTIVE   ;represents a change in drives.
F04D   BE                     CP   (HL)   
F04E   C8                     RET   Z   
F04F   77                     LD   (HL),A   ;yes it does, log it in.
F050   C3 23 F0               JP   LOGINDRV   
F053                          ; 
F053                          ;   This is the 'auto disk select' routine. The firsst byte
F053                          ; of the fcb is examined for a drive specification. If non
F053                          ; zero then the drive will be selected and loged in.
F053                          ; 
F053   3E FF        AUTOSEL:   LD   A,0FFH   ;say 'auto-select activated'.
F055   32 E0 F1               LD   (AUTO),A   
F058   2A 43 E7               LD   HL,(PARAMS)   ;get drive specified.
F05B   7E                     LD   A,(HL)   
F05C   E6 1F                  AND   1FH   ;look at lower 5 bits.
F05E   3D                     DEC   A   ;adjust for (1=A, 2=B) etc.
F05F   32 D8 F1               LD   (EPARAM),A   ;and save for the select routine.
F062   FE 1E                  CP   1EH   ;check for 'no change' condition.
F064   D2 77 F0               JP   NC,AUTOSL1   ;yes, don't change.
F067   3A 42 E7               LD   A,(ACTIVE)   ;we must change, save currently active
F06A   32 E1 F1               LD   (OLDDRV),A   ;drive.
F06D   7E                     LD   A,(HL)   ;and save first byte of fcb also.
F06E   32 E2 F1               LD   (AUTOFLAG),A   ;this must be non-zero.
F071   E6 E0                  AND   0E0H   ;whats this for (bits 6,7 are used for
F073   77                     LD   (HL),A   ;something)?
F074   CD 47 F0               CALL   SETDSK   ;select and log in this drive.
F077   3A 41 E7     AUTOSL1:   LD   A,(USERNO)   ;move user number into fcb.
F07A   2A 43 E7               LD   HL,(PARAMS)   ;(* upper half of first byte *)
F07D   B6                     OR   (HL)   
F07E   77                     LD   (HL),A   
F07F   C9                     RET   ;and return (all done).
F080                          ; 
F080                          ;   Function to return the current cp/m version number.
F080                          ; 
F080   3E 22        GETVER:   LD   A,022H   ;version 2.2
F082   C3 01 E7               JP   SETSTAT   
F085                          ; 
F085                          ;   Function to reset the disk system.
F085                          ; 
F085   21 00 00     RSTDSK:   LD   HL,0   ;clear write protect status and log
F088   22 AF F1               LD   (WRTPRT),HL   ;in vector.
F08B   22 B1 F1               LD   (LOGIN),HL   
F08E   AF                     XOR   A   ;select drive 'A'.
F08F   32 42 E7               LD   (ACTIVE),A   
F092   21 80 00               LD   HL,TBUFF   ;setup default dma address.
F095   22 B3 F1               LD   (USERDMA),HL   
F098   CD DC E9               CALL   DEFDMA   
F09B   C3 23 F0               JP   LOGINDRV   ;now log in drive 'A'.
F09E                          ; 
F09E                          ;   Function to open a specified file.
F09E                          ; 
F09E   CD 74 E9     OPENFIL:   CALL   CLEARS2   ;clear 's2' byte.
F0A1   CD 53 F0               CALL   AUTOSEL   ;select proper disk.
F0A4   C3 53 EC               JP   OPENIT   ;and open the file.
F0A7                          ; 
F0A7                          ;   Function to close a specified file.
F0A7                          ; 
F0A7   CD 53 F0     CLOSEFIL:   CALL   AUTOSEL   ;select proper disk.
F0AA   C3 A4 EC               JP   CLOSEIT   ;and close the file.
F0AD                          ; 
F0AD                          ;   Function to return the first occurence of a specified file
F0AD                          ; name. If the first byte of the fcb is '?' then the name will
F0AD                          ; not be checked (get the first entry no matter what).
F0AD                          ; 
F0AD   0E 00        GETFST:   LD   C,0   ;prepare for special search.
F0AF   EB                     EX   DE,HL   
F0B0   7E                     LD   A,(HL)   ;is first byte a '?'?
F0B1   FE 3F                  CP   '?'   
F0B3   CA C4 F0               JP   Z,GETFST1   ;yes, just get very first entry (zero length match).
F0B6   CD A8 E8               CALL   SETEXT   ;get the extension byte from fcb.
F0B9   7E                     LD   A,(HL)   ;is it '?'? if yes, then we want
F0BA   FE 3F                  CP   '?'   ;an entry with a specific 's2' byte.
F0BC   C4 74 E9               CALL   NZ,CLEARS2   ;otherwise, look for a zero 's2' byte.
F0BF   CD 53 F0               CALL   AUTOSEL   ;select proper drive.
F0C2   0E 0F                  LD   C,15   ;compare bytes 0-14 in fcb (12&13 excluded).
F0C4   CD 1A EB     GETFST1:   CALL   FINDFST   ;find an entry and then move it into
F0C7   C3 EB E9               JP   MOVEDIR   ;the users dma space.
F0CA                          ; 
F0CA                          ;   Function to return the next occurence of a file name.
F0CA                          ; 
F0CA   2A DB F1     GETNXT:   LD   HL,(SAVEFCB)   ;restore pointers. note that no
F0CD   22 43 E7               LD   (PARAMS),HL   ;other dbos calls are allowed.
F0D0   CD 53 F0               CALL   AUTOSEL   ;no error will be returned, but the
F0D3   CD 2F EB               CALL   FINDNXT   ;results will be wrong.
F0D6   C3 EB E9               JP   MOVEDIR   
F0D9                          ; 
F0D9                          ;   Function to delete a file by name.
F0D9                          ; 
F0D9   CD 53 F0     DELFILE:   CALL   AUTOSEL   ;select proper drive.
F0DC   CD 9E EB               CALL   ERAFILE   ;erase the file.
F0DF   C3 03 EB               JP   STSTATUS   ;set status and return.
F0E2                          ; 
F0E2                          ;   Function to execute a sequential read of the specified
F0E2                          ; record number.
F0E2                          ; 
F0E2   CD 53 F0     READSEQ:   CALL   AUTOSEL   ;select proper drive then read.
F0E5   C3 BE ED               JP   RDSEQ   
F0E8                          ; 
F0E8                          ;   Function to write the net sequential record.
F0E8                          ; 
F0E8   CD 53 F0     WRTSEQ:   CALL   AUTOSEL   ;select proper drive then write.
F0EB   C3 00 EE               JP   WTSEQ   
F0EE                          ; 
F0EE                          ;   Create a file function.
F0EE                          ; 
F0EE   CD 74 E9     FCREATE:   CALL   CLEARS2   ;clear the 's2' byte on all creates.
F0F1   CD 53 F0               CALL   AUTOSEL   ;select proper drive and get the next
F0F4   C3 26 ED               JP   GETEMPTY   ;empty directory space.
F0F7                          ; 
F0F7                          ;   Function to rename a file.
F0F7                          ; 
F0F7   CD 53 F0     RENFILE:   CALL   AUTOSEL   ;select proper drive and then switch
F0FA   CD 18 EC               CALL   CHGNAMES   ;file names.
F0FD   C3 03 EB               JP   STSTATUS   
F100                          ; 
F100                          ;   Function to return the login vector.
F100                          ; 
F100   2A B1 F1     GETLOG:   LD   HL,(LOGIN)   
F103   C3 2B F1               JP   GETPRM1   
F106                          ; 
F106                          ;   Function to return the current disk assignment.
F106                          ; 
F106   3A 42 E7     GETCRNT:   LD   A,(ACTIVE)   
F109   C3 01 E7               JP   SETSTAT   
F10C                          ; 
F10C                          ;   Function to set the dma address.
F10C                          ; 
F10C   EB           PUTDMA:   EX   DE,HL   
F10D   22 B3 F1               LD   (USERDMA),HL   ;save in our space and then get to
F110   C3 DC E9               JP   DEFDMA   ;the bios with this also.
F113                          ; 
F113                          ;   Function to return the allocation vector.
F113                          ; 
F113   2A C1 F1     GETALOC:   LD   HL,(ALOCVECT)   
F116   C3 2B F1               JP   GETPRM1   
F119                          ; 
F119                          ;   Function to return the read-only status vector.
F119                          ; 
F119   2A AF F1     GETROV:   LD   HL,(WRTPRT)   
F11C   C3 2B F1               JP   GETPRM1   
F11F                          ; 
F11F                          ;   Function to set the file attributes (read-only, system).
F11F                          ; 
F11F   CD 53 F0     SETATTR:   CALL   AUTOSEL   ;select proper drive then save attributes.
F122   CD 3D EC               CALL   SAVEATTR   
F125   C3 03 EB               JP   STSTATUS   
F128                          ; 
F128                          ;   Function to return the address of the disk parameter block
F128                          ; for the current drive.
F128                          ; 
F128   2A BD F1     GETPARM:   LD   HL,(DISKPB)   
F12B   22 45 E7     GETPRM1:   LD   (STATUS),HL   
F12E   C9                     RET   
F12F                          ; 
F12F                          ;   Function to get or set the user number. If (E) was (FF)
F12F                          ; then this is a request to return the current user number.
F12F                          ; Else set the user number from (E).
F12F                          ; 
F12F   3A D8 F1     GETUSER:   LD   A,(EPARAM)   ;get parameter.
F132   FE FF                  CP   0FFH   ;get user number?
F134   C2 3D F1               JP   NZ,SETUSER   
F137   3A 41 E7               LD   A,(USERNO)   ;yes, just do it.
F13A   C3 01 E7               JP   SETSTAT   
F13D   E6 1F        SETUSER:   AND   1FH   ;no, we should set it instead. keep low
F13F   32 41 E7               LD   (USERNO),A   ;bits (0-4) only.
F142   C9                     RET   
F143                          ; 
F143                          ;   Function to read a random record from a file.
F143                          ; 
F143   CD 53 F0     RDRANDOM:   CALL   AUTOSEL   ;select proper drive and read.
F146   C3 95 EF               JP   READRAN   
F149                          ; 
F149                          ;   Function to compute the file size for random files.
F149                          ; 
F149   CD 53 F0     WTRANDOM:   CALL   AUTOSEL   ;select proper drive and write.
F14C   C3 9E EF               JP   WRITERAN   
F14F                          ; 
F14F                          ;   Function to compute the size of a random file.
F14F                          ; 
F14F   CD 53 F0     FILESIZE:   CALL   AUTOSEL   ;select proper drive and check file length
F152   C3 D4 EF               JP   RANSIZE   
F155                          ; 
F155                          ;   Function #37. This allows a program to log off any drives.
F155                          ; On entry, set (DE) to contain a word with bits set for those
F155                          ; drives that are to be logged off. The log-in vector and the
F155                          ; write protect vector will be updated. This must be a M/PM
F155                          ; special function.
F155                          ; 
F155   2A 43 E7     LOGOFF:   LD   HL,(PARAMS)   ;get drives to log off.
F158   7D                     LD   A,L   ;for each bit that is set, we want
F159   2F                     CPL   ;to clear that bit in (LOGIN)
F15A   5F                     LD   E,A   ;and (WRTPRT).
F15B   7C                     LD   A,H   
F15C   2F                     CPL   
F15D   2A B1 F1               LD   HL,(LOGIN)   ;reset the login vector.
F160   A4                     AND   H   
F161   57                     LD   D,A   
F162   7D                     LD   A,L   
F163   A3                     AND   E   
F164   5F                     LD   E,A   
F165   2A AF F1               LD   HL,(WRTPRT)   
F168   EB                     EX   DE,HL   
F169   22 B1 F1               LD   (LOGIN),HL   ;and save.
F16C   7D                     LD   A,L   ;now do the write protect vector.
F16D   A3                     AND   E   
F16E   6F                     LD   L,A   
F16F   7C                     LD   A,H   
F170   A2                     AND   D   
F171   67                     LD   H,A   
F172   22 AF F1               LD   (WRTPRT),HL   ;and save. all done.
F175   C9                     RET   
F176                          ; 
F176                          ;   Get here to return to the user.
F176                          ; 
F176   3A E0 F1     GOBACK:   LD   A,(AUTO)   ;was auto select activated?
F179   B7                     OR   A   
F17A   CA 93 F1               JP   Z,GOBACK1   
F17D   2A 43 E7               LD   HL,(PARAMS)   ;yes, but was a change made?
F180   36 00                  LD   (HL),0   ;(* reset first byte of fcb *)
F182   3A E2 F1               LD   A,(AUTOFLAG)   
F185   B7                     OR   A   
F186   CA 93 F1               JP   Z,GOBACK1   
F189   77                     LD   (HL),A   ;yes, reset first byte properly.
F18A   3A E1 F1               LD   A,(OLDDRV)   ;and get the old drive and select it.
F18D   32 D8 F1               LD   (EPARAM),A   
F190   CD 47 F0               CALL   SETDSK   
F193   2A 0F E7     GOBACK1:   LD   HL,(USRSTACK)   ;reset the users stack pointer.
F196   F9                     LD   SP,HL   
F197   2A 45 E7               LD   HL,(STATUS)   ;get return status.
F19A   7D                     LD   A,L   ;force version 1.4 compatability.
F19B   44                     LD   B,H   
F19C   C9                     RET   ;and go back to user.
F19D                          ; 
F19D                          ;   Function #40. This is a special entry to do random i/o.
F19D                          ; For the case where we are writing to unused disk space, this
F19D                          ; space will be zeroed out first. This must be a M/PM special
F19D                          ; purpose function, because why would any normal program even
F19D                          ; care about the previous contents of a sector about to be
F19D                          ; written over.
F19D                          ; 
F19D   CD 53 F0     WTSPECL:   CALL   AUTOSEL   ;select proper drive.
F1A0   3E 02                  LD   A,2   ;use special write mode.
F1A2   32 D7 F1               LD   (MODE),A   
F1A5   0E 00                  LD   C,0   ;set write indicator.
F1A7   CD 09 EF               CALL   POSITN1   ;position the file.
F1AA   CC 05 EE               CALL   Z,WTSEQ1   ;and write (if no errors).
F1AD   C9                     RET   
F1AE                          ; 
F1AE                          ;**************************************************************
F1AE                          ;*
F1AE                          ;*     BDOS data storage pool.
F1AE                          ;*
F1AE                          ;**************************************************************
F1AE                          ; 
F1AE   E5           EMPTYFCB:   DB   0E5H   ;empty directory segment indicator.
F1AF   00 00        WRTPRT:   DW   0   ;write protect status for all 16 drives.
F1B1   00 00        LOGIN:    DW   0   ;drive active word (1 bit per drive).
F1B3   80 00        USERDMA:   DW   080H   ;user's dma address (defaults to 80h).
F1B5                          ; 
F1B5                          ;   Scratch areas from parameter block.
F1B5                          ; 
F1B5   00 00        SCRATCH1:   DW   0   ;relative position within dir segment for file (0-3).
F1B7   00 00        SCRATCH2:   DW   0   ;last selected track number.
F1B9   00 00        SCRATCH3:   DW   0   ;last selected sector number.
F1BB                          ; 
F1BB                          ;   Disk storage areas from parameter block.
F1BB                          ; 
F1BB   00 00        DIRBUF:   DW   0   ;address of directory buffer to use.
F1BD   00 00        DISKPB:   DW   0   ;contains address of disk parameter block.
F1BF   00 00        CHKVECT:   DW   0   ;address of check vector.
F1C1   00 00        ALOCVECT:   DW   0   ;address of allocation vector (bit map).
F1C3                          ; 
F1C3                          ;   Parameter block returned from the bios.
F1C3                          ; 
F1C3   00 00        SECTORS:   DW   0   ;sectors per track from bios.
F1C5   00           BLKSHFT:   DB   0   ;block shift.
F1C6   00           BLKMASK:   DB   0   ;block mask.
F1C7   00           EXTMASK:   DB   0   ;extent mask.
F1C8   00 00        DSKSIZE:   DW   0   ;disk size from bios (number of blocks-1).
F1CA   00 00        DIRSIZE:   DW   0   ;directory size.
F1CC   00 00        ALLOC0:   DW   0   ;storage for first bytes of bit map (dir space used).
F1CE   00 00        ALLOC1:   DW   0   
F1D0   00 00        OFFSET:   DW   0   ;first usable track number.
F1D2   00 00        XLATE:    DW   0   ;sector translation table address.
F1D4                          ; 
F1D4                          ; 
F1D4   00           CLOSEFLG:   DB   0   ;close flag (=0ffh is extent written ok).
F1D5   00           RDWRTFLG:   DB   0   ;read/write flag (0ffh=read, 0=write).
F1D6   00           FNDSTAT:   DB   0   ;filename found status (0=found first entry).
F1D7   00           MODE:     DB   0   ;I/o mode select (0=random, 1=sequential, 2=special random).
F1D8   00           EPARAM:   DB   0   ;storage for register (E) on entry to bdos.
F1D9   00           RELBLOCK:   DB   0   ;relative position within fcb of block number written.
F1DA   00           COUNTER:   DB   0   ;byte counter for directory name searches.
F1DB   00 00 00 00  SAVEFCB:   DW   0,0   ;save space for address of fcb (for directory searches).
F1DF   00           BIGDISK:   DB   0   ;if =0 then disk is > 256 blocks long.
F1E0   00           AUTO:     DB   0   ;if non-zero, then auto select activated.
F1E1   00           OLDDRV:   DB   0   ;on auto select, storage for previous drive.
F1E2   00           AUTOFLAG:   DB   0   ;if non-zero, then auto select changed drives.
F1E3   00           SAVNXT:   DB   0   ;storage for next record number to access.
F1E4   00           SAVEXT:   DB   0   ;storage for extent number of file.
F1E5   00 00        SAVNREC:   DW   0   ;storage for number of records in file.
F1E7   00 00        BLKNMBR:   DW   0   ;block number (physical sector) used within a file or logical sect
F1E9   00 00        LOGSECT:   DW   0   ;starting logical (128 byte) sector of block (physical sector).
F1EB   00           FCBPOS:   DB   0   ;relative position within buffer for fcb of file of interest.
F1EC   00 00        FILEPOS:   DW   0   ;files position within directory (0 to max entries -1).
F1EE                          ; 
F1EE                          ;   Disk directory buffer checksum bytes. One for each of the
F1EE                          ; 16 possible drives.
F1EE                          ; 
F1EE   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 CKSUMTBL:   DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
F1FE                          ; 
F1FE                          ;   Extra space ?
F1FE                          ; 
F1FE   00 00 00 00            DB   0,0,0,0   
F202                          ; 
F202                          ;**************************************************************
F202                          ;*
F202                          ;*        B I O S   J U M P   T A B L E
F202                          ;*
F202                          ;**************************************************************
F202                          ; 
F200                          .ORG   0F200H   
F200   C3 00 00     BOOT:     JP   0   ;NOTE WE USE FAKE DESTINATIONS
F203   C3 00 00     WBOOT:    JP   0   
F206   C3 00 00     CONST:    JP   0   
F209   C3 00 00     CONIN:    JP   0   
F20C   C3 00 00     CONOUT:   JP   0   
F20F   C3 00 00     LIST:     JP   0   
F212   C3 00 00     PUNCH:    JP   0   
F215   C3 00 00     READER:   JP   0   
F218   C3 00 00     HOME:     JP   0   
F21B   C3 00 00     SELDSK:   JP   0   
F21E   C3 00 00     SETTRK:   JP   0   
F221   C3 00 00     SETSEC:   JP   0   
F224   C3 00 00     SETDMA:   JP   0   
F227   C3 00 00     READ:     JP   0   
F22A   C3 00 00     WRITE:    JP   0   
F22D   C3 00 00     PRSTAT:   JP   0   
F230   C3 00 00     SECTRN:   JP   0   
F233                          ; 
F233                          ;*
F233                          ;******************   E N D   O F   C P / M   *****************
F233                          ;*


_PC         F233
MEM         003E
IOBYTE      0003
TDRIVE      0004
ENTRY       0005
TFCB        005C
TBUFF       0080
TBASE       0100
CNTRLC      0003
CNTRLE      0005
BS          0008
TAB         0009
LF          000A
FF          000C
CR          000D
CNTRLP      0010
CNTRLR      0012
CNTRLS      0013
CNTRLU      0015
CNTRLX      0018
CNTRLZ      001A
DEL         007F
CBASE       DC00
INBUFF      DC06
INPOINT     DC88
NAMEPNT     DC8A
PRINT       DC8C
PRINTB      DC92
CRLF        DC98
SPACE       DCA2
PLINE       DCA7
PLINE2      DCAC
RESDSK      DCB8
DSKSEL      DCBD
ENTRY1      DCC3
OPEN        DCCB
OPENFCB     DCD0
CLOSE       DCDA
SRCHFST     DCDF
SRCHNXT     DCE4
SRCHFCB     DCE9
DELETE      DCEF
ENTRY2      DCF4
RDREC       DCF9
READFCB     DCFE
WRTREC      DD04
CREATE      DD09
RENAM       DD0E
GETUSR      DD13
GETSETUC    DD15
SETCDRV     DD1A
MOVECD      DD29
UPPER       DD30
GETINP      DD39
GETINP1     DD96
GETINP2     DDA7
GETINP3     DDAB
GETINP4     DDBA
CHKCON      DDC2
GETDSK      DDD0
STDDMA      DDD5
DMASET      DDD8
DELBATCH    DDDD
VERIFY      DDF5
VERIFY1     DDFD
SYNERR      DE09
SYNERR1     DE0F
SYNERR2     DE22
CHECK       DE30
NONBLANK    DE4F
ADDHL       DE59
CONVFST     DE5E
CONVERT     DE60
CONVRT1     DE89
CONVRT2     DE90
CONVRT3     DE96
CONVRT4     DE98
CONVRT5     DEA9
CONVRT6     DEAB
CONVRT7     DEAF
CONVRT8     DEB9
GETEXT      DEC0
GETEXT1     DEC8
GETEXT2     DED9
GETEXT3     DEDB
GETEXT4     DEDF
GETEXT5     DEE9
GETEXT6     DEF0
GETEXT7     DEF2
GETEXT8     DF01
GETEXT9     DF09
NUMCMDS     0006
CMDTBL      DF10
PATTRN1     DF28
SEARCH      DF2E
SEARCH1     DF33
SEARCH2     DF3C
SEARCH3     DF4F
SEARCH4     DF54
CLEARBUF    DF58
COMMAND     DF5C
CMMND1      DF82
CMMND2      DF98
CMDADR      DFC1
HALT        DFCF
RDERROR     DFD9
RDERR       DFDF
NONE        DFEA
NOFILE      DFF0
DECODE      DFF8
DECODE1     E008
DECODE2     E02A
DECODE3     E033
DECODE4     E03A
MOVE3       E040
HL2DE       E042
EXTRACT     E04B
DSELECT     E054
RESETDR     E066
DIRECT      E077
DIRECT1     E088
DIRECT2     E08F
DIRECT3     E098
DIRECT4     E0CC
DIRECT5     E0D4
DIRECT6     E0D9
DRECT63     E0F7
DRECT65     E0F9
DIRECT7     E10E
DIRECT8     E10F
DIRECT9     E11B
ERASE       E11F
ERASE1      E142
YESNO       E152
TYPE        E15D
TYPE1       E174
TYPE2       E177
TYPE3       E187
TYPE4       E1A0
TYPE5       E1A7
SAVE        E1AD
SAVE1       E1D4
SAVE2       E1F1
SAVE3       E1FB
SAVE4       E201
NOSPACE     E207
RENAME      E210
RENAME1     E23F
RENAME2     E259
RENAME3     E25E
RENAME4     E26D
RENAME5     E273
RENAME6     E279
EXISTS      E282
USER        E28E
UNKNOWN     E2A5
UNKWN1      E2C4
UNKWN2      E2CD
UNKWN3      E2E1
UNKWN4      E301
UNKWN5      E330
UNKWN6      E33E
UNKWN7      E343
UNKWN8      E34F
UNKWN9      E36B
UNKWN0      E371
BADLOAD     E37A
COMFILE     E383
GETBACK     E386
GETBACK1    E389
CCPSTACK    E3AB
BATCH       E3AB
BATCHFCB    E3AC
FCB         E3CD
RTNCODE     E3EE
CDRIVE      E3EF
CHGDRV      E3F0
NBYTES      E3F1
PATTRN2     E400
FBASE       E406
BADSCTR     E409
BADSLCT     E40B
RODISK      E40D
ROFILE      E40F
FBASE1      E411
NFUNCTS     0029
FUNCTNS     E447
ERROR1      E499
ERROR2      E4A5
ERROR3      E4AB
ERROR4      E4B1
ERROR5      E4B4
BDOSERR     E4BA
BDOSDRV     E4C6
BADSEC      E4CA
BADSEL      E4D5
FILERO      E4DC
DISKRO      E4E1
PRTERR      E4E5
GETCHAR     E4FB
GETECHO     E506
CHKCHAR     E514
CKCONSOL    E523
CKCON1      E542
CKCON2      E545
OUTCHAR     E548
OUTCHR1     E562
OUTCHR2     E579
SHOWIT      E57F
OUTCON      E590
OUTCON1     E596
BACKUP      E5A4
BACKUP1     E5AC
NEWLINE     E5B1
NEWLN1      E5B9
OUTCRLF     E5C9
PRTMESG     E5D3
RDBUFF      E5E1
RDBUF1      E5EF
RDBUF2      E5F1
RDBUF3      E616
RDBUF4      E626
RDBUF5      E637
RDBUF6      E648
RDBUF7      E64E
RDBUF8      E65F
RDBUF9      E66B
RDBUF10     E670
RDBUF11     E678
RDBUF12     E68A
RDBUF13     E699
RDBUF14     E6A6
RDBUF15     E6A9
RDBUF16     E6BD
RDBUF17     E6C1
GETCON      E6C8
GETRDR      E6CE
DIRCIO      E6D4
DIRC1       E6E0
GETIOB      E6ED
SETIOB      E6F3
PRTSTR      E6F8
GETCSTS     E6FE
SETSTAT     E701
RTN         E704
IOERR1      E705
OUTFLAG     E70A
STARTING    E70B
CURPOS      E70C
PRTFLAG     E70D
CHARBUF     E70E
USRSTACK    E70F
STKAREA     E741
USERNO      E741
ACTIVE      E742
PARAMS      E743
STATUS      E745
SLCTERR     E747
JUMPHL      E74A
DE2HL       E74F
DE2HL1      E750
SELECT      E759
SELECT1     E79F
HOMEDRV     E7A3
DOREAD      E7B4
DOWRITE     E7BA
IORET       E7BD
TRKSEC      E7C5
TRKSEC1     E7D3
TRKSEC2     E7E6
TRKSEC3     E7FC
TRKSEC4     E811
GETBLOCK    E840
GETBLK1     E847
GETBLK2     E855
GETBLK3     E85E
EXTBLK      E860
EXTBLK1     E873
COMBLK      E879
CHKBLK      E886
LOGICAL     E88C
LOGICL1     E892
SETEXT      E8A8
SETHLDE     E8B0
STRDATA     E8BD
SETNREC     E8D4
STNREC1     E8E0
SHIFTR      E8EC
SHIFTR1     E8ED
CHECKSUM    E8F9
CHKSUM1     E8FF
SHIFTL      E906
SHIFTL1     E907
SETBIT      E90D
GETWPRT     E920
WRTPRTD     E92E
CHKROFL     E946
CKROF1      E949
CHKWPRT     E956
FCB2HL      E960
ADDA2HL     E966
GETS2       E96B
CLEARS2     E974
SETS2B7     E97A
MOREFLS     E981
CHKNMBR     E98E
SUBHL       E997
SETDIR      E99E
CHECKDIR    E9A0
CHKDIR1     E9C6
DIRWRITE    E9C8
DIRREAD     E9D6
DEFDMA      E9DC
DIRDMA      E9E2
DIRDMA1     E9E5
MOVEDIR     E9EB
CKFILPOS    E9F7
STFILPOS    EA00
NXENTRY     EA07
NXENT1      EA1B
NXENT2      EA22
CKBITMAP    EA37
CKBMAP1     EA58
STBITMAP    EA5E
STBMAP1     EA66
SETFILE     EA6D
SETFL1      EA77
SETFL2      EA8A
SETFL3      EA90
SETFL4      EA9F
BITMAP      EAA5
BITMAP1     EAB3
BITMAP2     EAD4
BITMAP3     EAF8
STSTATUS    EB03
SAMEXT      EB09
FINDFST     EB1A
FINDNXT     EB2F
FNDNXT1     EB4C
FNDNXT2     EB55
FNDNXT3     EB75
FNDNXT4     EB7E
FNDNXT5     EB85
FNDNXT6     EB96
ERAFILE     EB9E
ERAFIL1     EBA6
FNDSPACE    EBC0
FNDSPA1     EBC2
FNDSPA2     EBD3
FNDSPA3     EBEE
FNDSPA4     EBF6
FCBSET      EBFF
UPDATE      EC03
UPDATE1     EC12
CHGNAMES    EC18
CHGNAM1     EC29
SAVEATTR    EC3D
SAVATR1     EC42
OPENIT      EC53
OPENIT1     EC5C
OPENIT2     EC8D
MOVEWORD    EC96
CLOSEIT     ECA4
CLOSEIT1    ECCF
CLOSEIT2    ECDD
CLOSEIT3    ECE3
CLOSEIT4    ECEA
CLOSEIT5    ECFF
CLOSEIT6    ED19
CLOSEIT7    ED21
GETEMPTY    ED26
GETMT1      ED48
GETNEXT     ED5C
GTNEXT1     ED85
GTNEXT2     ED90
GTNEXT3     EDAE
GTNEXT4     EDB1
GTNEXT5     EDB8
RDSEQ       EDBE
RDSEQ1      EDC3
RDSEQ2      EDE8
RDSEQ3      EDFD
WTSEQ       EE00
WTSEQ1      EE05
WTSEQ2      EE3D
WTSEQ3      EE4A
WTSEQ4      EE66
WTSEQ5      EE6E
WTSEQ6      EE70
WTSEQ7      EE8E
WTSEQ8      EE9C
WTSEQ9      EEBD
WTSEQ10     EED4
WTSEQ99     EEE1
WTSEQ11     EF00
WTSEQ12     EF02
POSITION    EF05
POSITN1     EF09
POSITN2     EF49
POSITN3     EF81
POSITN4     EF86
POSITN5     EF8D
READRAN     EF95
WRITERAN    EF9E
COMPRAND    EFA7
RANSIZE     EFD4
RANSIZ1     EFE6
RANSIZ2     F008
RANSIZ3     F00E
SETRAN      F010
LOGINDRV    F023
SETDSK      F047
AUTOSEL     F053
AUTOSL1     F077
GETVER      F080
RSTDSK      F085
OPENFIL     F09E
CLOSEFIL    F0A7
GETFST      F0AD
GETFST1     F0C4
GETNXT      F0CA
DELFILE     F0D9
READSEQ     F0E2
WRTSEQ      F0E8
FCREATE     F0EE
RENFILE     F0F7
GETLOG      F100
GETCRNT     F106
PUTDMA      F10C
GETALOC     F113
GETROV      F119
SETATTR     F11F
GETPARM     F128
GETPRM1     F12B
GETUSER     F12F
SETUSER     F13D
RDRANDOM    F143
WTRANDOM    F149
FILESIZE    F14F
LOGOFF      F155
GOBACK      F176
GOBACK1     F193
WTSPECL     F19D
EMPTYFCB    F1AE
WRTPRT      F1AF
LOGIN       F1B1
USERDMA     F1B3
SCRATCH1    F1B5
SCRATCH2    F1B7
SCRATCH3    F1B9
DIRBUF      F1BB
DISKPB      F1BD
CHKVECT     F1BF
ALOCVECT    F1C1
SECTORS     F1C3
BLKSHFT     F1C5
BLKMASK     F1C6
EXTMASK     F1C7
DSKSIZE     F1C8
DIRSIZE     F1CA
ALLOC0      F1CC
ALLOC1      F1CE
OFFSET      F1D0
XLATE       F1D2
CLOSEFLG    F1D4
RDWRTFLG    F1D5
FNDSTAT     F1D6
MODE        F1D7
EPARAM      F1D8
RELBLOCK    F1D9
COUNTER     F1DA
SAVEFCB     F1DB
BIGDISK     F1DF
AUTO        F1E0
OLDDRV      F1E1
AUTOFLAG    F1E2
SAVNXT      F1E3
SAVEXT      F1E4
SAVNREC     F1E5
BLKNMBR     F1E7
LOGSECT     F1E9
FCBPOS      F1EB
FILEPOS     F1EC
CKSUMTBL    F1EE
BOOT        F200
WBOOT       F203
CONST       F206
CONIN       F209
CONOUT      F20C
LIST        F20F
PUNCH       F212
READER      F215
HOME        F218
SELDSK      F21B
SETTRK      F21E
SETSEC      F221
SETDMA      F224
READ        F227
WRITE       F22A
PRSTAT      F22D
SECTRN      F230
